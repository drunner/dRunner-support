#!/bin/bash
set -o nounset

#          88  88888888ba                                                                  
#          88  88      "8b                                                                 
#          88  88      ,8P                                                                 
#  ,adPPYb,88  88aaaaaa8P'  88       88  8b,dPPYba,   8b,dPPYba,    ,adPPYba,  8b,dPPYba,  
# a8"    `Y88  88""""88'    88       88  88P'   `"8a  88P'   `"8a  a8P_____88  88P'   "Y8  
# 8b       88  88    `8b    88       88  88       88  88       88  8PP"""""""  88          
# "8a,   ,d88  88     `8b   "8a,   ,a88  88       88  88       88  "8b,   ,aa  88          
#  `"8bbdP"Y8  88      `8b   `"YbbdP'Y8  88       88  88       88   `"Ybbd8"'  88          
#                                                                                                                                                                           
#                                                                                                          
#  manage docker containers in a simple and consistent way.
#  
#  See:
#    https://github.com/j842/drunner
#
# ------------------------------------------------------------------

# MYDIR - the directory this script is in and BUILDTIME - time image built.
readonly MYDIR=$( dirname "$(readlink -f "$0")" )
if [ ! -e "${MYDIR}/buildtime" ]; then BUILDTIME="BROKEN BUILD"
else . "${MYDIR}/buildtime"
fi

# Other global constanst from dr-install in this file.
readonly DR_CFG_FILE="/etc/drunner/drunner.cfg"

# Global constants.
readonly REQDFILES=("install" "destroy" "backup" "restore" "help" "enter")
readonly COPYIMAGE="drunner/baseimage-alpine"

readonly BACKUP_MAIN="backup.tar.7z"
readonly SERVICECFG="service.cfg"

#------------------------------------------------------------------------------------

# die MESSAGE 
function die {
   if [ -n "$1" ]; then
      echo "$1" <&2
   else
      echo "Unexpected error. Exiting."<&2
   fi
   exit 1
}
function dieusage {
   echo "Usage:">&2
   die "   $1"
}

#------------------------------------------------------------------------------------

function volexists {
  docker volume ls | grep "$1" > /dev/null
}

#------------------------------------------------------------------------------------

function checkdir {
   if [ -z "$1" ]; then die "Installation broken. Config file ${DR_CFG_FILE} doesn't set $2."; fi
   if [ ! -d "$1" ]; then die "Installation broken. $2 is set to $1 but it doesn't exist."; fi
}

#------------------------------------------------------------------------------------

function initglobals {
   # defines ROOTPATH, DRSERVICESPATH, SUPPORTIMAGE, DRBINPATH
   source "${DR_CFG_FILE}"
   
   # Check basic directories are okay
   checkdir "${ROOTPATH}" "ROOTPATH"
   checkdir "${DRSERVICESPATH}" "DRSERVICESPATH"
   checkdir "${DRBINPATH}" "DRBINPATH"
   
   if [ ! -v PULLONUPDATE ]; then die "Installation broken. Configuration file ${DR_CFG_FILE} doesn't set PULLONUPDATE."; fi
   
   readonly SUPPORTPATH="${DRBINPATH}/support"
}

#------------------------------------------------------------------------------------

# serviceline SERVICE SHORTHELP
function serviceline {
   printf "   %-15s - %-55s\n" "$1" "$2"
}

#------------------------------------------------------------------------------------

# showservices
function showservices {
   # list available services. 
   echo "AVAILABLE SERVICES"
   find "$DRSERVICESPATH" -maxdepth 1 -mindepth 1 -type d | while read SPATH; do 
      if [ -e "${SPATH}/bin/_variables" ]; then
         source "${SPATH}/bin/_variables"
         serviceline "${SPATH##*/}" "$IMAGENAME"
      else
         serviceline "${SPATH##*/}" "Broken service"
      fi
   done
}

#------------------------------------------------------------------------------------

# showusage
function showusage {
cat <<EOF >&2

NAME
   dr - docker runner

VERSION
   ${BUILDTIME}
   
SYNOPSIS
   drunner clean
   drunner list
   drunner update
   
   [PASS=?] drunner backup  SERVICENAME BACKUPFILE
   [PASS=?] drunner restore BACKUPFILE  SERVICENAME  
   
   drunner install IMAGENAME [SERVICENAME]
   drunner update  SERVICENAME
   drunner destroy SERVICENAME
   drunner enter   SERVICENAME [ARGS]
   
   SERVICENAME
   SERVICENAME COMMAND ARGS
   
DESCRIPTION
   Provides a standard way to manage and run containers supporting dr.
   Intended to be used both manually and via Ansible.
   See https://github.com/j842/drunner
   
EXIT CODE
   0   - success
   1   - error
   3   - no changes made
   
EOF
}

#------------------------------------------------------------------------------------

# command_exists
function command_exists { command -v "$1" >/dev/null 2>&1 ; }

#------------------------------------------------------------------------------------

# getUSERID
function getUSERID {
   USERID=$(docker run --rm -it "${IMAGENAME}" /bin/bash -c "id -u | tr -d '\r\n'")
}


#------------------------------------------------------------------------------------

# destroy
# destroys everything we can about a service!
function destroy {   
   if [ -v SERVICEVARIABLESPATH ] && [ -e "$SERVICEVARIABLESPATH" ]; then
      source "$SERVICEVARIABLESPATH"
   fi   
   
   # call destroy in service.
   if [ -v SERVICEBINPATH ] && [ -e "${SERVICEBINPATH}/destroy" ]; then 
      echo "Calling destroy from within service."
      bash "${SERVICEBINPATH}/destroy"
   fi
   
   # remove volume container.
   if [ -v DOCKERVOLS ]; then
      for VOLNAME in "${DOCKERVOLS[@]}"; do      
         echo "Destroying volume $VOLNAME."
         docker volume rm "$VOLNAME" >/dev/null
      done
   fi
   
   # remove launch script
   if [ -v SERVICENAME ] && [ -e "/usr/local/bin/${SERVICENAME}" ]; then 
      echo "Removing command $SERVICENAME."
      rm "/usr/local/bin/${SERVICENAME}"
   fi
   
   # delete service directoy.
   if [ -v SERVICEPATH ] && [ -d "${SERVICEPATH}" ]; then
      echo "Removing all service files from ${SERVICEPATH}."
      rm -r "${SERVICEPATH}"
   fi
   
   if [ -v SERVICENAME ]; then
      echo "Service $SERVICENAME has been destroyed."
   else
      echo "No service specified."
   fi
}

#------------------------------------------------------------------------------------

# install_checkimage 
function install_checkimage {
   if [ ! -e "${SUPPORTPATH}/validator" ]; then
      die "Missing dr file: ${SUPPORTPATH}/validator"
   fi
   docker run --rm -v "${SUPPORTPATH}:/support" "${IMAGENAME}" /bin/bash -c "/support/validator"
   if [ "$?" -ne 0 ]; then 
      die "Unable to continue because ${IMAGENAME} is not Docker Runner compatible."
   fi
   
   echo "${IMAGENAME} is dr compatible.">&2
}

#------------------------------------------------------------------------------------

# install_createlaunchscript
function install_createlaunchscript {
   local SCRIPTPATH="/usr/local/bin/${SERVICENAME}"
   cat <<EOF >"$SCRIPTPATH"
#!/bin/bash
drunner servicecmd ${SERVICENAME} "\$@"
EOF
   chmod a+x "$SCRIPTPATH"
}

#------------------------------------------------------------------------------------

# install_checkReqdFiles
function install_checkReqdFiles {
   # Check mandatory files made it over to host okay from the container.
   for HFILE in "${REQDFILES[@]}"; do
      if [ ! -e "${SERVICEBINPATH}/${HFILE}" ]; then 
         echo "Install failed - ${HFILE} is required but wasn't copied from image ${IMAGE}." 
         rm -r "${SERVICEPATH}"
         exit 1
      fi
   done
}

#------------------------------------------------------------------------------------

# install_createVolumes
function install_createVolumes {
   # create the necessary volume containers.
   local DNAME="dr-install-volcreate"
   
   if [ -v VOLUMES ]; then
      for i in "${!DOCKERVOLS[@]}"; do      
         VOLNAME="${DOCKERVOLS[i]}"
         VOLPATH="${VOLUMES[i]}"

         if volexists "$VOLNAME" ; then 
            echo "A docker volume already exists for: $VOLNAME. Reusing it.";
         else
            docker volume create --name="$DNAME" >/dev/null
            # set permissions on config volume
            docker run --name="$DNAME" -v "${VOLNAME}:${VOLPATH}" "${COPYIMAGE}" \
               /bin/bash -c "chown ${USERID}:root ${VOLPATH} && date >> ${VOLPATH}/install_date"
            docker rm "$DNAME" >/dev/null 
         fi
      done     
  fi
}


#------------------------------------------------------------------------------------

# recreateServiceBinPath
# called by both install and SERVICE update.
function recreateServiceBinPath {   
   # the directory that the container will update.
   if [ -d "${SERVICEBINPATH}" ]; then rm -r "${SERVICEBINPATH}" ; fi
   mkdir -p "${SERVICEBINPATH}"

   # we need the user id for the account that the image uses.
   getUSERID
   if [ -z "$USERID" ] || [ "${USERID}" -eq 0 ]; then die "Internal error - USERID for image is not a normal user." ; fi

   # allow the container to write into this folder.
   chown "${USERID}" "${SERVICEBINPATH}"
   
   # assumes docker image does not use entrypoint. Could instead override entrypoint maybe.
   docker run --rm -it -v "${SERVICEBINPATH}:/tempcopy" "${IMAGENAME}" /bin/bash -c "cp -r /drunner/* /tempcopy/"                             
   if [ $? -ne 0 ]; then 
      echo "Failed to copy files.">&2 
      echo "You will need to reinstall the service.">&2
      rm -r "${SERVICEPATH}"
      exit 1
   fi  
   # tighten up permissions
   chown -R root:root "${SERVICEBINPATH}"
   chmod -R a-w "${SERVICEBINPATH}"
   
   # create _variables file.
   if [ ! -e "${SERVICEBINPATH}/${SERVICECFG}" ]; then die "Missing $SERVICECFG file for $SERVICENAME" ; fi
   if [ ! -v SERVICENAME ]; then die "SERVICENAME undefined." ; fi

   source "${SERVICEBINPATH}/${SERVICECFG}"
   
   if [ -v VOLUMES ]; then
      for i in "${!VOLUMES[@]}"; do
         DOCKERVOLS[$((i))]="dr-${SERVICENAME}-${VOLUMES[i]//[![:alnum:]]/}"
         DOCKEROPTS[$((2*i))]="-v"
         DOCKEROPTS[$((2*i+1))]="${DOCKERVOLS[i]}:${VOLUMES[i]}"
      done
   fi
   STR_DOCKERVOLS=""
   STR_DOCKEROPTS=""
   STR_VOLUMES=""
   STR_CONTAINERS=""
   
   local DATESTAMP="$(TZ=Pacific/Auckland date -u +"%a, %d %b %Y %X %z")"
   if [ -v DOCKERVOLS ]; then printf -v STR_DOCKERVOLS "\"%s\" " "${DOCKERVOLS[@]}" ; fi
   if [ -v DOCKEROPTS ]; then printf -v STR_DOCKEROPTS "\"%s\" " "${DOCKEROPTS[@]}" ; fi
   if [ -v VOLUMES ];    then printf -v STR_VOLUMES    "\"%s\" " "${VOLUMES[@]}"    ; fi
   if [ -v EXTRACONTAINERS ]; then printf -v STR_CONTAINERS "\"%s\" " "${EXTRACONTAINERS[@]}" ; fi
   cat <<EOF >"${SERVICEVARIABLESPATH}"
# Auto generated by Docker Runner
# ${DATESTAMP}
VOLUMES=($STR_VOLUMES)
CONTAINERS=($STR_CONTAINERS)
DOCKERVOLS=($STR_DOCKERVOLS)
DOCKEROPTS=($STR_DOCKEROPTS)
SERVICENAME="${SERVICENAME}"
IMAGENAME="${IMAGENAME}"
INSTALLTIME="${DATESTAMP}"
EOF
}

#------------------------------------------------------------------------------------

# install
# global variables ready: ROOTPATH, DRSERVICESPATH, SUPPORTIMAGE, SERVICENAME, SERVICEPATH, SERVICEVARIABLESPATH, IMAGENAME
function install {   
   if [ -z "$IMAGENAME" ]; then echo "dr install requires IMAGENAME.">&2 ; exit 1 ; fi
   if [ -z "$SERVICENAME" ]; then echo "dr install requires SERVICENAME.">&2 ; exit 1 ; fi

   if [ -d "${SERVICEPATH}" ]; then
      echo "A service is already installed at ${SERVICEPATH}. Initialisation cancelled.">&2
      echo "You might want   dr ${SERVICENAME} update  instead.">&2
      exit 1
   fi
      
   install_checkimage
   recreateServiceBinPath
   install_checkReqdFiles
   install_createVolumes
   install_createlaunchscript
      
   # Finally run the install script in the service.         
   bash "${SERVICEBINPATH}/install" "${SERVICENAME}" "${IMAGENAME}"      
   
   if [ $? -ne 0 ]; then
      destroy
      die "Installation failed. System returned to clean state."
   fi
    
   # TODO: If we had errors then destroy everything!
   echo "Installation of service ${SERVICENAME} successful."
}

#------------------------------------------------------------------------------------

# updatedr - udpates docker runner.
function updatedr {
   # use the container to get the latest dr-install script.
   local TEMPDIR="$(mktemp -d)"
   docker run -i -t --name="get-drunner-install" -v "${TEMPDIR}:/tempdir" \
               "${SUPPORTIMAGE}" get-drunner-install "/tempdir"
   local RVAL="$?"
   docker rm "get-drunner-install" >/dev/null 2>&1

   if [ "$RVAL" -ne 0 ]; then die "Unable to get drunner-install.">&2 ; fi
   if [ ! -e "${TEMPDIR}/drunner-install" ]; then die "drunner-install mysteriously missing.">&2 ; fi
   
   # run it to update the installation.
   bash "${TEMPDIR}/drunner-install" "${ROOTPATH}" "${PULLONUPDATE}"
   rm -r "${TEMPDIR}"
   exit 0
}


#------------------------------------------------------------------------------------

# updateservice - udpates the service.
function updateservice {
   # ensure we have the latest support image. Issue here in that we don't update any other
   # images within the container.
   if [ "$PULLONUPDATE" -eq 1 ]; then
      docker pull "${IMAGENAME}"
      if [ "$?" -ne 0 ]; then die "Unable to pull required Docker image ${IMAGENAME}." ; fi
      
      # also pull any extra containers specified in the service's service.cfg.
      if [ -v CONTAINERS ]; then
         for CONTNAME in "${CONTAINERS[@]}"; do
            docker pull "${CONTNAME}"
            if [ "$?" -ne 0 ]; then die "Unable to pull required Docker image ${CONTNAME}." ; fi
         done
      fi
         
   fi
   recreateServiceBinPath
}

#------------------------------------------------------------------------------------

# backup BACKUPFILE
# global variables ready: ROOTPATH, DRSERVICESPATH, SUPPORTIMAGE, SERVICENAME, SERVICEPATH, SERVICEVARIABLESPATH, IMAGENAME
function backup {
   if [ -z "$1" ]; then die "No BACKUPFILE was specified." ; fi
   local BACKUPFILE=$(realpath "$1" | tr -d '\r\n')
   if [ -e "$BACKUPFILE" ]; then die "$BACKUPFILE already exists. Aborting." ; fi
   
   local TEMPROOT="$(mktemp -d)"
   
   ( # SUBSHELL so we can tidy up easily if it goes wrong.
      # bail if any command returns an error!
      set -e
      
      local TEMPPARENT="${TEMPROOT}/backup"
      local TEMPF="${TEMPPARENT}/drbackup"
      mkdir -p "$TEMPF"
      local TEMPC="${TEMPPARENT}/containerbackup"
      mkdir -p "$TEMPC"
      
      # output variables needed for restore to the tempparent folder
      STR_DOCKERVOLS=""
      if [ -v DOCKERVOLS ]; then printf -v STR_DOCKERVOLS "\"%s\" " "${DOCKERVOLS[@]}" ; fi
      cat <<EOF >"${TEMPPARENT}/_oldvariables"
# Auto generated by Docker Runner
OLDDOCKERVOLS=($STR_DOCKERVOLS)
IMAGENAME="${IMAGENAME}"
EOF

      # call through to container to backup anything there in a subfolder.
      # important this is called before backing up any volume containers, as
      # it might put stuff in them.
      getUSERID
      chown "${USERID}" "${TEMPC}"
      bash "${SERVICEBINPATH}/backup" "$TEMPC"
                  
      # back up our volume containers
      if [ -v DOCKERVOLS ]; then
         for VOLNAME in "${DOCKERVOLS[@]}"; do      
            volexists "$VOLNAME"
            if [ $? -ne 0 ]; then die "A docker volume required for the backup was missing: $VOLNAME"; fi
            "${SUPPORTPATH}/compress" "$VOLNAME" "${TEMPF}" "${VOLNAME}.tar.7z"
            if [ ! -e "${TEMPF}/${VOLNAME}.tar.7z" ]; then die "Unable to back up ${VOLNAME}." ; fi
         done      
      fi
      
      # Compress everything with password
      "${SUPPORTPATH}/compress" "$TEMPPARENT" "$TEMPROOT" "${BACKUP_MAIN}"
      mv "${TEMPROOT}/${BACKUP_MAIN}" "$BACKUPFILE"
   )
   RVAL="$?" 
   rm -r "${TEMPROOT}"
   if [ $RVAL -ne 0 ]; then die "Backup failed. Temp files have been removed." ; fi
   
   echo " ">&2
   echo "Backed up to $BACKUPFILE succesfully.">&2
}

#------------------------------------------------------------------------------------

# restore BACKUPFILE
function restore {
   if [ -z "$1" ]; then die "No BACKUPFILE was specified." ; fi
   local BACKUPFILE=$(realpath "$1" | tr -d '\r\n')
   if [ ! -e "$BACKUPFILE" ]; then die "$BACKUPFILE doesn't exist. Aborting." ; fi
   if [ -e "$SERVICEPATH" ]; then die "$SERVICENAME exists - destroy it before restoring from backup." ; fi
   
   local TEMPROOT="$(mktemp -d)"
   
   ( # SUBSHELL so we can tidy up easily if it goes wrong.
      # bail if any command returns an error!
      set -e

      local TEMPPARENT="${TEMPROOT}/backup"
      mkdir -p "$TEMPPARENT"
      local TEMPF="${TEMPPARENT}/drbackup"
      local TEMPC="${TEMPPARENT}/containerbackup"
      
      # decompress the main backup
      cp "$BACKUPFILE" "${TEMPROOT}/${BACKUP_MAIN}"
      "${SUPPORTPATH}/decompress" "$TEMPPARENT" "$TEMPROOT" "$BACKUP_MAIN"

      # loads the old DOCKERVOLS and IMAGENAME
      source "${TEMPPARENT}/_oldvariables"
         
      # check backup has key files.
      if [ ! -e "$TEMPC" ]; then die "Backup corrupt. Missing ${TEMPC}."; fi
      if [ -v OLDDOCKERVOLS ]; then
         for NEEDEDFILE in "${OLDDOCKERVOLS[@]}"; do
            if [ ! -e "${TEMPF}/${NEEDEDFILE}.tar.7z" ]; then die "Backup corrupt. Missing backup file for docker volume ${NEEDEDFILE}."; fi
         done
      fi
      
      # now can install base service. Updates DOCKERVOLS.
      install
         
      # restore volumes.
      # zip file names are based on the _old_ DOCKERVOLS, new volume name based on hte new ones.
      if [ -v OLDDOCKERVOLS ]; then
         if [ "${#OLDDOCKERVOLS[@]}" -gt "${#DOCKERVOLS[@]}" ]; then die "The number of volume containers the image requires has decreased. Not safe to restore." ; fi
         if [ "${#OLDDOCKERVOLS[@]}" -lt "${#DOCKERVOLS[@]}" ]; then echo "The number of volume containers the image specifies has increased. We'll restore what we can, but this container might not work :/" ; fi

         for i in "${!OLDDOCKERVOLS[@]}"; do      
            OLDVOLNAME="${OLDDOCKERVOLS[i]}"
            NEWVOLNAME="${DOCKERVOLS[i]}"
            
            "${SUPPORTPATH}/decompress" "$NEWVOLNAME" "${TEMPF}" "${OLDVOLNAME}.tar.7z"
         done
      fi
      
      # call through to container to restore its backup in TEMPC. Imporant this is the last step,
      # so it can use any docker volumes, the _variables file etc.
      bash "${SERVICEBINPATH}/restore" "$TEMPC"
   )
   RVAL="$?"
   rm -r "${TEMPROOT}"  
   if [ $RVAL -ne 0 ]; then 
      if [ -e "${SERVICEPATH}" ]; then destroy ; fi
      die "Restore failed. Temp files have been removed, system back in clean state."
   fi
      
   echo "The backup ${BACKUPFILE##*/} has been restored to ${SERVICENAME}."
   
   # our globals haven't been updated outside the subshell (IMAGENAME not set for example) so exit to be safe.
   exit 0
}

#------------------------------------------------------------------------------------

function showservicehelp {
   local HELPSCRIPT="${SERVICEBINPATH}/help"
   if [ -e "${SERVICEVARIABLESPATH}" ] && [ -e "$HELPSCRIPT" ]; then
      source "$SERVICEVARIABLESPATH"
      bash "${HELPSCRIPT}" "${SERVICENAME}" "${IMAGENAME}"
      exit 0
   else
      showservices
      echo " ">&2
      die "Service ${SERVICENAME} does not exist."
   fi
}

#------------------------------------------------------------------------------------

# setServiceName SERVICENAME
function setServiceName {
   if [ -z "$1" ]; then die "SERVICENAME was not specified!" ; fi
   SERVICENAME="$1"
   readonly SERVICEPATH="${DRSERVICESPATH}/${SERVICENAME}"
   readonly SERVICEBINPATH="${SERVICEPATH}/bin"
   readonly SERVICEVARIABLESPATH="${SERVICEBINPATH}/_variables"
}

#------------------------------------------------------------------------------------

# readVariables
function readVariables {
   # Read in _variables from the service.
   if [ ! -d "$SERVICEPATH" ]; then showservices ; die "Service $SERVICENAME does not exist." ; fi
   if [ ! -e "$SERVICEVARIABLESPATH" ]; then die "Service ${SERVICENAME} is corrupt (missing its _variables file)." ; fi
   source "$SERVICEVARIABLESPATH"   
}


#------------------------------------------------------------------------------------

# processServiceCommands ARGS
function processServiceCommands {
   case "$1" in
      update)
         updateservice
         ;;
                  
      backup)
         if [ "$#" -eq 3 ]; then
            backup "$3"
         else
            dieusage "[PASS=?] drunner backup SERVICENAME BACKUPFILE"
         fi
         ;;
         
      enter)
         if [ "$#" -lt 2 ]; then
            showservicehelp
         else
            SCRIPTTORUN="${SERVICEBINPATH}/enter"
            shift 2
            bash "${SCRIPTTORUN}" "$@"
         fi
         ;;
         
      # servicecmd SERVICENAME COMMAND
      servicecmd)
         if [ "$#" -lt 3 ] || [ "$3" -eq "help" ]; then
            showservicehelp
         else
            SCRIPTTORUN="${SERVICEBINPATH}/${3}"
            shift 3
            if [ -e "${SCRIPTTORUN}" ]; then
               bash "${SCRIPTTORUN}" "$@"
            else
               showservicehelp
            fi
         fi
         ;;

      *)
         showservicehelp
   esac     
}


#------------------------------------------------------------------------------------

# processdRunnerCommands ARGS
function processdRunnerCommands {
   
   # start with high level commands (clean, list, update), and commands on a service
   # that do not expect the service to be fully configured (install, restore, destroy)
   case "$1" in 
      clean)
         docker run --rm -v /var/run/docker.sock:/var/run/docker.sock spotify/docker-gc
         exit 0
         ;;
         
      list)
         showservices
         exit 0
         ;;
         
      update)
         if [ "$#" -eq 1 ]; then
            updatedr
            exit 0
         fi
         # otherwise fall through - we want to update the service.
         ;;
         
      install)
         if [ "$#" -lt 2 ] || [ "$#" -gt 3 ]; then
            dieusage "drunner install IMAGENAME [SERVICENAME]"
         fi
         
         IMAGENAME="$2"
         if [ "$#" -eq 3 ]; then 
            setServiceName "$3" 
         else
            setServiceName "${IMAGENAME##*/}"
         fi
         
         install
         exit 0
         ;;

      restore)
         if [ "$#" -ne 3 ]; then
            dieusage "[PASS=?] drunner restore BACKUPFILE  SERVICENAME  "
            exit 0
         fi
         setServiceName "$3"         
         restore "$1"
         exit 0
         ;;

      destroy)
         if [ "$#" -ne 2 ]; then
            dieusage "[PASS=?] drunner destroy SERVICENAME"
            exit 0
         fi
         setServiceName "$2"
         destroy 
         exit 0
         ;;        
   esac  
}

#------------------------------------------------------------------------------------

# ███╗   ███╗ █████╗ ██╗███╗   ██╗
# ████╗ ████║██╔══██╗██║████╗  ██║
# ██╔████╔██║███████║██║██╔██╗ ██║
# ██║╚██╔╝██║██╔══██║██║██║╚██╗██║
# ██║ ╚═╝ ██║██║  ██║██║██║ ╚████║
# ╚═╝     ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝

function main {                                

   if [ "$EUID" -ne 0 ]; then echo "Please run as root" ; exit 1 ; fi
   if ! command_exists docker ; then die "Requires docker to be installed." ; fi
   if [ "$(uname -rv | grep -c Debian)" -eq 0 ]; then die "Built for Debian only." ; fi

   # defines ROOTPATH,  DRSERVICESPATH,  SUPPORTIMAGE,  DRBINPATH, SUPPORTPATH
   initglobals

   if [ "$#" -eq 0 ]; then 
      showusage
      showservices
      exit 0
   fi
   
   # Process (clean, list, update, install, restore, destroy)
   # These ones don't require a valid service.
   processdRunnerCommands "$@"
   
   # all other commands have SERVICENAME as second argument.
   if [ "$#" -lt 2 ]; then
      showservicehelp
      exit 0
   fi

   # everything from now on is expected to be based on a valid service,
   # so we should be able to read in the variables file.
   setServiceName "$2"
   readVariables

   processServiceCommands "$@"

}

#--------------------------------------------------------------------------
main "$@"
