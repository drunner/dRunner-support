#!/bin/bash
set -o nounset

# ██████╗  ██████╗  ██████╗██╗  ██╗███████╗██████╗     ██████╗ ██╗   ██╗███╗   ██╗███╗   ██╗███████╗██████╗ 
# ██╔══██╗██╔═══██╗██╔════╝██║ ██╔╝██╔════╝██╔══██╗    ██╔══██╗██║   ██║████╗  ██║████╗  ██║██╔════╝██╔══██╗
# ██║  ██║██║   ██║██║     █████╔╝ █████╗  ██████╔╝    ██████╔╝██║   ██║██╔██╗ ██║██╔██╗ ██║█████╗  ██████╔╝
# ██║  ██║██║   ██║██║     ██╔═██╗ ██╔══╝  ██╔══██╗    ██╔══██╗██║   ██║██║╚██╗██║██║╚██╗██║██╔══╝  ██╔══██╗
# ██████╔╝╚██████╔╝╚██████╗██║  ██╗███████╗██║  ██║    ██║  ██║╚██████╔╝██║ ╚████║██║ ╚████║███████╗██║  ██║
# ╚═════╝  ╚═════╝  ╚═════╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝    ╚═╝  ╚═╝ ╚═════╝ ╚═╝  ╚═══╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝
#                                                                                                          
#                                                                                                          
#  manage docker containers in a simple and consistent way.
#  
#  See:
#    https://github.com/j842/dr
#
# ------------------------------------------------------------------

# MYDIR - the directory this script is in and BUILDTIME - time image built.
readonly MYDIR=$( dirname "$(readlink -f "$0")" )
if [ ! -e "${MYDIR}/buildtime" ]; then BUILDTIME="BROKEN BUILD"
else . "${MYDIR}/buildtime"
fi

# Other global constanst from dr-install in this file.
readonly DR_CFG_FILE="/etc/dr/dr.cfg"

# Global constants.
readonly SERVICECFGFILE="service.cfg"
readonly SERVICEBINDIR="bin"
readonly REQDFILES=("install" "destroy" "backup" "restore" "help" "enter")
readonly COPYIMAGE="j842/dr-baseimage-alpine"

readonly BACKUP_VOLZIP="config_volume_container.tar.7z"
readonly BACKUP_MAIN="backup.tar.7z"

#------------------------------------------------------------------------------------

# die MESSAGE 
function die {
   if [ -n "$1" ]; then
      echo "$1" <&2
   else
      echo "Unexpected error. Exiting."<&2
   fi
   exit 1
}
function dieusage {
   echo "Usage:">&2
   die "   $1"
}

#------------------------------------------------------------------------------------

function checkdir {
   if [ -z "$1" ]; then die "Installation broken. Config file ${DR_CFG_FILE} doesn't set $2."; fi
   if [ ! -d "$1" ]; then die "Installation broken. $2 is set to $1 but it doesn't exist."; fi
}

function initglobals {
   # defines ROOTPATH, DRSERVICESPATH, SUPPORTIMAGE, DRBINPATH
   . "${DR_CFG_FILE}"
   
   # Check basic directories are okay
   checkdir "${ROOTPATH}" "ROOTPATH"
   checkdir "${DRSERVICESPATH}" "DRSERVICESPATH"
   checkdir "${DRBINPATH}" "DRBINPATH"
   
   readonly SUPPORTPATH="${DRBINPATH}/support"
}

#------------------------------------------------------------------------------------

# serviceline SERVICE SHORTHELP
function serviceline {
   printf "   %-15s - %-55s\n" "$1" "$2"
}

#------------------------------------------------------------------------------------

# showservices
function showservices {
   # list available services. 
   echo "AVAILABLE SERVICES"
   find "$DRSERVICESPATH" -maxdepth 1 -mindepth 1 -type d | while read SPATH; do 
      if [ -e "${SPATH}/${SERVICECFGFILE}" ]; then
         . "${SPATH}/${SERVICECFGFILE}"
         serviceline "${SPATH##*/}" "$SERVICEIMAGENAME"
      else
         serviceline "${SPATH##*/}" "Broken service"
      fi
   done
}

#------------------------------------------------------------------------------------

# showusage
function showusage {
cat <<EOF >&2

NAME
   dr - docker runner

VERSION
   ${BUILDTIME}
   
SYNOPSIS
   dr clean
   dr list
   dr update
   
   [PASS=?] dr SERVICENAME backup BACKUPFILE
   [PASS=?] dr SERVICENAME restore BACKUPFILE
   dr SERVICENAME install IMAGENAME
   dr SERVICENAME update
   dr SERVICENAME destroy
   
   dr SERVICENAME
   dr SERVICENAME enter
   dr SERVICENAME COMMAND ARGS
   
   Once SERVICENAME is installed you can call it directly, e.g.
   SERVICENAME update
   This convenience just calls through to  dr SERVICENAME update .

DESCRIPTION
   Provides a standard way to manage and run containers supporting dr.
   Intended to be used both manually and via Ansible.
   See https://github.com/j842/dr
   
EXIT CODE
   0   - success
   1   - error
   3   - no changes made
   
EOF
}

#------------------------------------------------------------------------------------

# command_exists
function command_exists { command -v "$1" >/dev/null 2>&1 ; }

#------------------------------------------------------------------------------------

# getUSERID
function getUSERID {
   USERID=$(docker run --rm -it "${IMAGENAME}" /bin/bash -c "id -u | tr -d '\r\n'")
}

#------------------------------------------------------------------------------------

# checkimage 
function checkimage {
   if [ ! -e "${SUPPORTPATH}/validator" ]; then
      die "Missing dr file: ${SUPPORTPATH}/validator"
   fi
   docker run --rm -v "${SUPPORTPATH}:/support" "${IMAGENAME}" /bin/bash -c "/support/validator"
   if [ "$?" -ne 0 ]; then 
      die "Unable to continue because ${IMAGENAME} is not Docker Runner compatible."
   fi
   
   echo "${IMAGENAME} is dr compatible.">&2
}

#------------------------------------------------------------------------------------

# createlaunchscript
function createlaunchscript {
   local SCRIPTPATH="/usr/local/bin/${SERVICENAME}"
   cat <<EOF >"$SCRIPTPATH"
#!/bin/bash
dr ${SERVICENAME} "\$@"
EOF
   chmod a+x "$SCRIPTPATH"
}

#------------------------------------------------------------------------------------

# copydrfiles
function copydrfiles {   
   # the directory that the container will update.
   local SERVICEBINPATH="${SERVICEPATH}/${SERVICEBINDIR}"
   if [ -d "${SERVICEBINPATH}" ]; then rm -r "${SERVICEBINPATH}" ; fi
   mkdir -p "${SERVICEBINPATH}"

   # we need the user id for the account that the image uses.
   getUSERID
   if [ -z "$USERID" ] || [ "${USERID}" -eq 0 ]; then die "Internal error - USERID for image is not a normal user." ; fi

   # allow the container to write into this folder.
   chown "${USERID}:root" "${SERVICEBINPATH}"
   
   # assumes docker image does not use entrypoint. Could instead override entrypoint maybe.
   docker run --rm -it -v "${SERVICEBINPATH}:/tempcopy" "${IMAGENAME}" /bin/bash -c "cp -r /dr/* /tempcopy/"                             
   if [ $? -ne 0 ]; then 
      echo "Failed to copy files.">&2 
      echo "You will need to reinstall the service.">&2
      rm -r "${SERVICEPATH}"
      exit 1
   fi  
   # tighten up permissions
   chown -R root:root "${SERVICEBINPATH}"
   chmod -R a-w "${SERVICEBINPATH}"
}

#------------------------------------------------------------------------------------

# initdrservice
function initSERVICEPATH {
   # can only call when service ROOTPATH not present (for safety)
   if [ -d "${SERVICEPATH}" ]; then
      echo "A service is already installed at ${SERVICEPATH}. Initialisation cancelled.">&2
      echo "You might want   dr ${SERVICENAME} update  instead.">&2
      exit 1
   fi

   copydrfiles

   # add standard dr config stuff.
   local DATESTAMP="$(LC_ALL=C date -u +"%a, %d %b %Y %X %z")"
   
   cat <<EOF >"${SERVICECFGPATH}"
# Docker Runner configuration file for ${SERVICENAME} - ${IMAGENAME}
# Last modified ${DATESTAMP}

SERVICEIMAGENAME=${IMAGENAME}
EOF

   # Check mandatory files made it over to host okay from the container.
   for HFILE in "${REQDFILES[@]}"; do
      if [ ! -e "${SERVICEPATH}/${SERVICEBINDIR}/${HFILE}" ]; then 
         echo "Install failed - ${HFILE} is required but wasn't copied from image ${IMAGE}." 
         rm -r "${SERVICEPATH}"
         exit 1
      fi
   done
}

#------------------------------------------------------------------------------------

# install
# global variables ready: ROOTPATH, DRSERVICESPATH, SUPPORTIMAGE, SERVICENAME, SERVICEPATH, SERVICECFGPATH, IMAGENAME
function install {   
   if [ -z "$IMAGENAME" ]; then echo "dr install requires IMAGENAME.">&2 ; exit 1 ; fi
   if [ -z "$SERVICENAME" ]; then echo "dr install requires SERVICENAME.">&2 ; exit 1 ; fi

   checkimage
   
   local DNAME="dr-install"

   # --- all four globals have been set.
   initSERVICEPATH
   
   # create the standard config volume container.
   docker volume create --name="dr-${SERVICENAME}-config" >/dev/null
   # set permissions on config volume
   docker run --name="$DNAME" -v "dr-${SERVICENAME}-config:/config" "${COPYIMAGE}" \
      /bin/bash -c "chown ${USERID}:root /config && date >> /config/install_date"
   docker rm "$DNAME" >/dev/null 
    
   # Run the install script, e.g. to create volume containers.
   # todo: tidy up return/exit codes!         
   bash "${SERVICEPATH}/${SERVICEBINDIR}/install" "${SERVICENAME}" "${IMAGENAME}"
   
   # allow direct execution of SERVICENAME without typing dr
   createlaunchscript
    
   # TODO: If we had errors then destroy everything!
   echo "Installation of service ${SERVICENAME} successful."
}

#------------------------------------------------------------------------------------

# update
function update {
   # use the container to get the latest dr-install script.
   local TEMPDIR="$(mktemp -d)"
   chmod a+rwx "${TEMPDIR}"
   docker run -i -t --name="get-dr-install" -v "${TEMPDIR}:/tempdir" \
               "${SUPPORTIMAGE}" get-dr-install "/tempdir"
   local RVAL="$?"
   docker rm "get-dr-install" >/dev/null 2>&1

   if [ "$RVAL" -ne 0 ]; then die "Unable to get dr-install.">&2 ; fi
   if [ ! -e "${TEMPDIR}/dr-install" ]; then die "dr-install mysteriously missing.">&2 ; fi
   
   # run it to update the installation.
   bash "${TEMPDIR}/dr-install" "${ROOTPATH}"
   rm -r "${TEMPDIR}"
   exit 0
}

#------------------------------------------------------------------------------------

# destroy
# global variables ready: ROOTPATH, DRSERVICESPATH, SUPPORTIMAGE, SERVICENAME, SERVICEPATH, SERVICECFGPATH, IMAGENAME
function destroy {
   if [ -z "$SERVICENAME" ]; then die "dr destroy requires SERVICENAME to be set." ; fi
   if [ ! -d "$SERVICEPATH" ]; then echo "The service ${SERVICENAME} does not exist.">&2 ; showservices ; exit 1 ; fi
   
   local RVALD=0

   # if the install process created a destroy script then run it, e.g. to destroy volume containers.
   # todo: tidy up return/exit codes!         
   if [ -e "${SERVICEPATH}/${SERVICEBINDIR}/destroy" ]; then
      bash "${SERVICEPATH}/${SERVICEBINDIR}/destroy" "${SERVICENAME}" "${IMAGENAME}"
   else 
      echo "Missing destroy script: ${SERVICEPATH}/${SERVICEBINDIR}/destroy" >&2
      RVALD=1
   fi      
   
   # remove volume container.
   docker volume rm "dr-${SERVICENAME}-config" >/dev/null
   
   # remove launch script
   if [ -e "/usr/local/bin/${SERVICENAME}" ]; then rm "/usr/local/bin/${SERVICENAME}" ; fi
   
   # clean up service directoy.
   rm -r "${SERVICEPATH}"
   
   exit $RVALD
}

#------------------------------------------------------------------------------------

# backup BACKUPFILE
# global variables ready: ROOTPATH, DRSERVICESPATH, SUPPORTIMAGE, SERVICENAME, SERVICEPATH, SERVICECFGPATH, IMAGENAME
function backup {
   if [ -z "$1" ]; then die "No BACKUPFILE was specified." ; fi
   local BACKUPFILE=$(realpath "$1" | tr -d '\r\n')
   if [ -e "$BACKUPFILE" ]; then die "$BACKUPFILE already exists. Aborting." ; fi
   
   local TEMPROOT="$(mktemp -d)"
   
   ( # SUBSHELL so we can tidy up easily if it goes wrong.
      # bail if any command returns an error!
      set -e
      
      local TEMPPARENT="${TEMPROOT}/backup"
      local TEMPF="${TEMPPARENT}/drbackup"
      mkdir -p "$TEMPF"
      local TEMPC="${TEMPPARENT}/containerbackup"
      mkdir -p "$TEMPC"
      
      # back up the service config (SERVICECFGFILE) to the tempparent folder
      cp "$SERVICECFGPATH" "$TEMPPARENT"
         
      # back up our volume container (dr-${SERVICENAME}-config).
      "${SUPPORTPATH}/compress" "dr-${SERVICENAME}-config" "${TEMPF}" "${BACKUP_VOLZIP}"
      
      # call through to container to backup anything there in a subfolder.
      getUSERID
      chown "${USERID}" "${TEMPC}"
      SCRIPTTORUN="${SERVICEPATH}/${SERVICEBINDIR}/backup"
      bash "$SCRIPTTORUN" "$SERVICENAME" "$IMAGENAME" "$TEMPC"
         
      # Compress everything with password
      "${SUPPORTPATH}/compress" "$TEMPPARENT" "$TEMPROOT" "${BACKUP_MAIN}"
      mv "${TEMPROOT}/${BACKUP_MAIN}" "$BACKUPFILE"
   )
   RVAL="$?" 
   rm -r "${TEMPROOT}"
   if [ $RVAL -ne 0 ]; then die "Backup failed. Temp files have been removed." ; fi
   
   echo " ">&2
   echo "Backed up to $BACKUPFILE succesfully.">&2
}

#------------------------------------------------------------------------------------

# restore BACKUPFILE
function restore {
   if [ -z "$1" ]; then die "No BACKUPFILE was specified." ; fi
   local BACKUPFILE=$(realpath "$1" | tr -d '\r\n')
   if [ ! -e "$BACKUPFILE" ]; then die "$BACKUPFILE doesn't exist. Aborting." ; fi
   if [ -e "$SERVICEPATH" ]; then die "$SERVICENAME exists - destroy it before restoring from backup." ; fi
   
   local TEMPROOT="$(mktemp -d)"
   
   ( # SUBSHELL so we can tidy up easily if it goes wrong.
      # bail if any command returns an error!
      set -e

      local TEMPPARENT="${TEMPROOT}/backup"
      mkdir -p "$TEMPPARENT"
      local TEMPF="${TEMPPARENT}/drbackup"
      local TEMPC="${TEMPPARENT}/containerbackup"
      
      # decompress the main backup
      cp "$BACKUPFILE" "${TEMPROOT}/${BACKUP_MAIN}"
      "${SUPPORTPATH}/decompress" "$TEMPPARENT" "$TEMPROOT" "$BACKUP_MAIN"
         
      # check backup has key files.
      local KEYFILES=("${TEMPF}/${BACKUP_VOLZIP}" "${TEMPPARENT}/${SERVICECFGFILE}" "${TEMPC}")
      for NEEDEDFILE in "${KEYFILES[@]}"; do
         if [ ! -e "$NEEDEDFILE" ]; then die "Backup corrupt. Missing ${NEEDEDFILE}."; fi
      done
      
      # set IMAGENAME - the only missing global var.
      . "${TEMPPARENT}/${SERVICECFGFILE}"
      IMAGENAME="$SERVICEIMAGENAME"

      # now can install base service
      install
         
      # restore our volume container (dr-${SERVICENAME}-config), first destroying the one install just created.
      "${SUPPORTPATH}/decompress" "dr-${SERVICENAME}-config" "${TEMPF}" "${BACKUP_VOLZIP}"

      # We restore our backed up configuration, first removing the one install just created.
      rm -f "${SERVICECFGPATH}"
      cp "${TEMPPARENT}/${SERVICECFGFILE}" "$SERVICECFGPATH" 
      
      # call through to container to restore its backup in TEMPC.
      SCRIPTTORUN="${SERVICEPATH}/${SERVICEBINDIR}/restore"
      bash "$SCRIPTTORUN" "$SERVICENAME" "$IMAGENAME" "$TEMPC"
   )
   RVAL="$?"
   rm -r "${TEMPROOT}"   
   if [ $RVAL -ne 0 ]; then die "Restore failed. Temp files have been removed." ; fi
      
   echo "Service ${SERVICENAME} has been restored successfully."
}

#------------------------------------------------------------------------------------


# retriveROOTPATH
function retrieveROOTPATH {
   DIRERR="Run   dr configure ROOTPATH   before any other commands."
   if [ ! -d "$DRETCDIR" ]; then die "$DIRERR"; fi
   ROOTPATH=$(<"${CFG_ROOTPATH}")
   if [ -z "$ROOTPATH" ]; then die "$DIRERR"; fi
   if [ ! -d "$ROOTPATH" ]; then die "$DIRERR"; fi
}

#------------------------------------------------------------------------------------

# setglobals
function setglobals {
   # expects SERVICENAME to be set.
   if [ -z "${SERVICENAME}" ]; then 
      die "SERVICENAME has not been set." 
   fi
   retrieveROOTPATH

   SERVICEPATH="${ROOTPATH}/${SERVICENAME}"
   if [ ! -d "$SERVICEPATH" ]; then echo "The service ${SERVICENAME} does not exist.">&2 ; showservices ; exit 1 ; fi

   if [ ! -e "${SERVICEPATH}/${CFG_IMAGENAME}" ]; then die "Error - ${CFG_IMAGENAME} doesn't exist."; fi
   IMAGENAME=$(<"${SERVICEPATH}/${CFG_IMAGENAME}")
   if [ -z "$IMAGENAME" ]; then die "Error - ${CFG_IMAGENAME} is empty." ; fi
}


function showservicehelp {
   local HELPSCRIPT="${SERVICEPATH}/${SERVICEBINDIR}/help"
   if [ -e "${HELPSCRIPT}" ]; then
      . "$SERVICECFGPATH"
      bash "${HELPSCRIPT}" "${SERVICENAME}" "${SERVICEIMAGENAME}"
      exit 0
   else
      showservices
      echo " ">&2
      die "Service ${SERVICENAME} does not exist."
   fi
}

#------------------------------------------------------------------------------------

# ███╗   ███╗ █████╗ ██╗███╗   ██╗
# ████╗ ████║██╔══██╗██║████╗  ██║
# ██╔████╔██║███████║██║██╔██╗ ██║
# ██║╚██╔╝██║██╔══██║██║██║╚██╗██║
# ██║ ╚═╝ ██║██║  ██║██║██║ ╚████║
# ╚═╝     ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝

function main {                                

   if [ "$EUID" -ne 0 ]; then echo "Please run as root" ; exit 1 ; fi
   if ! command_exists docker ; then die "Requires docker to be installed." ; fi
   if [ "$(uname -rv | grep -c Debian)" -eq 0 ]; then die "Built for Debian only." ; fi

   # defines ROOTPATH,  DRSERVICESPATH,  SUPPORTIMAGE,  DRBINPATH, SUPPORTPATH
   initglobals

   # check special commands with no SERVICENAME needed
   if [ "$#" -eq 0 ]; then 
      showusage
      showservices
      exit 0
   elif [ "$1" = "clean" ]; then
      docker run --rm -v /var/run/docker.sock:/var/run/docker.sock spotify/docker-gc
      exit 0
   elif [ "$1" = "list" ]; then
      showservices 
      exit 0
   elif [ "$1" = "update" ]; then
      update
      exit 0
   fi     

   # all other commands have SERVICENAME as first argument.
   SERVICENAME="$1"
   SERVICEPATH="${DRSERVICESPATH}/${SERVICENAME}"
   SERVICECFGPATH="${SERVICEPATH}/${SERVICECFGFILE}"

   # dr SERVICE with no other params.
   if [ "$#" -eq 1 ]; then
      showservicehelp
   fi

   # get the command to run and shift so $@ is the args.
   USERCOMMAND="$2"
   shift 2

   # HANDLE COMMANDS FOR A SERVICE THAT MIGHT NOT EXIST YET. We can't just read IMAGENAME from the service cfg.
   case "$USERCOMMAND" in
      install)
         if [ "$#" -eq 1 ]; then
            IMAGENAME="$1"
            install
            echo " ">&2
            showservicehelp
            exit 0
         else
            dieusage "dr SERVICENAME install IMAGENAME"
         fi
         ;;

      restore)
         if [ "$#" -eq 1 ]; then
            restore "$1"
            exit 0
         else
            dieusage "[PASS=?] dr SERVICENAME restore BACKUPFILE"
         fi
         ;;
      esac
   
   # -------------------------------------
   
   # If we've reached here then SERVICENAME is expected to exist. 
   # Read in SERVICEIMAGENAME from config file. 
   if [ ! -d "$SERVICEPATH" ]; then showservices ; die "Service $SERVICENAME does not exist." ; fi
   if [ ! -e "$SERVICECFGPATH" ]; then die "Service ${SERVICENAME} is corrupt (missing its configuration file)." ; fi
   . "$SERVICECFGPATH"
   IMAGENAME="$SERVICEIMAGENAME"

   # HANDLE COMMANDS FOR AN EXISTING SERVICE
   case "$USERCOMMAND" in
      update)
         copydrfiles
         ;;
         
      destroy)
         destroy 
         ;;         
         
      backup)
         if [ "$#" -eq 1 ]; then
            backup "$1"
         else
            dieusage "[PASS=?] dr SERVICENAME backup BACKUPFILE"
         fi
         ;;

      *)         
         SCRIPTTORUN="${SERVICEPATH}/${SERVICEBINDIR}/${USERCOMMAND}"
         if [ -e "${SCRIPTTORUN}" ]; then
            bash "${SCRIPTTORUN}" "${SERVICENAME}" "${IMAGENAME}" "$@"
         else
            showservicehelp
         fi
         ;;

   esac     
}

#--------------------------------------------------------------------------
main "$@"
