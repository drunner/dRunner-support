#!/bin/bash
set -o nounset


# ██████╗  ██████╗  ██████╗██╗  ██╗███████╗██████╗     ██████╗ ██╗   ██╗███╗   ██╗███╗   ██╗███████╗██████╗ 
# ██╔══██╗██╔═══██╗██╔════╝██║ ██╔╝██╔════╝██╔══██╗    ██╔══██╗██║   ██║████╗  ██║████╗  ██║██╔════╝██╔══██╗
# ██║  ██║██║   ██║██║     █████╔╝ █████╗  ██████╔╝    ██████╔╝██║   ██║██╔██╗ ██║██╔██╗ ██║█████╗  ██████╔╝
# ██║  ██║██║   ██║██║     ██╔═██╗ ██╔══╝  ██╔══██╗    ██╔══██╗██║   ██║██║╚██╗██║██║╚██╗██║██╔══╝  ██╔══██╗
# ██████╔╝╚██████╔╝╚██████╗██║  ██╗███████╗██║  ██║    ██║  ██║╚██████╔╝██║ ╚████║██║ ╚████║███████╗██║  ██║
# ╚═════╝  ╚═════╝  ╚═════╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝    ╚═╝  ╚═╝ ╚═════╝ ╚═╝  ╚═══╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝
#                                                                                                          
#                                                                                                          
#  manage docker containers in a simple and consistent way.
#  
#  See:
#    https://github.com/j842/dr
#
# ------------------------------------------------------------------


# Other global constanst from dr-install in this file.
readonly DR_CFG_FILE="/etc/dr/dr.cfg"

# Global constants.
readonly DRBINPATH="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

readonly SERVICECFGFILE="service.cfg"
readonly REQDFILES=("install" "destroy" "backup" "restore" "help" "enter" )
readonly COPYIMAGE="j842/dr-baseimage-alpine"

readonly BACKUP_HOSTZIP="config_host.tar.7z"
readonly BACKUP_VOLZIP="config_volume_container.tar.7z"
readonly BACKUP_MAIN="backup.tar.7z"

#------------------------------------------------------------------------------------

# die MESSAGE 
function die {
   if [ -n "$1" ]; then
      echo "$1" <&2
   else
      echo "Unexpected error. Exiting."<&2
   fi
   exit 1
}
function dieusage {
   echo "Usage:">&2
   die "   $1"
}

#------------------------------------------------------------------------------------

function checkdir {
   if [ -z "$1" ]; then die "Installation broken. Config file ${DR_CFG_FILE} doesn't set $2."; fi
   if [ ! -d "$1" ]; then die "Installation broken. $2 is set to $1 but it doesn't exist."; fi
}

function initglobals {
   # defines $ROOTPATH  $DRSERVICESPATH  $SUPPORTIMAGE
   . "${DR_CFG_FILE}"
   
   # Check basic directories are okay
   checkdir "${ROOTPATH}" "ROOTPATH"
   checkdir "${DRSERVICESPATH}" "DRSERVICESPATH"
}

#------------------------------------------------------------------------------------

# serviceline SERVICE SHORTHELP
function serviceline {
   printf "   %-15s - %-55s\n" "$1" "$2"
}

#------------------------------------------------------------------------------------

# showservices
function showservices {
   # list available services. 
   echo "AVAILABLE SERVICES"
   find "$DRSERVICESPATH" -maxdepth 1 -mindepth 1 -type d | while read SPATH; do 
      if [ -e "${SPATH}/${SERVICECFGFILE}" ]; then
         . "${SPATH}/${SERVICECFGFILE}"
         serviceline "${SPATH##*/}" "$SERVICEIMAGENAME"
      else
         serviceline "${SPATH##*/}" "Broken service"
      fi
   done
}

#------------------------------------------------------------------------------------

# showusage
function showusage {
cat <<'EOF' >&2

NAME
   dr - docker runner
   
SYNOPSIS
   dr clean
   dr list
   
   [PASS=?] dr SERVICENAME backup BACKUPFILE
   [PASS=?] dr SERVICENAME restore BACKUPFILE
   dr SERVICENAME install IMAGENAME
   dr SERVICENAME update
   dr SERVICENAME destroy
   
   dr SERVICENAME
   dr SERVICENAME enter
   dr SERVICENAME COMMAND ARGS
   
   Once SERVICENAME is installed you can call it directly, e.g.
   SERVICENAME update
   This convenience just calls through to dr SERVICENAME update.

DESCRIPTION
   Provides a standard way to manage and run containers supporting dr.
   Intended to be used both manually and via Ansible.
   See https://github.com/j842/dr
   
EXIT CODE
   0   - success
   1   - error
   3   - no changes made
   
EOF
}

#------------------------------------------------------------------------------------

# command_exists
function command_exists { command -v "$1" >/dev/null 2>&1 ; }

#------------------------------------------------------------------------------------

# configure
function configure {
   if [ -z "$ROOTPATH" ]; then echo "dr configure requires ROOTPATH argument.">&2 ; exit 1 ; fi
   mkdir -p "$DRETCPATH"   # ensure directrory exists.   
   echo "$ROOTPATH" > "${CFG_ROOTPATH}"
   
   # set up standard docker user and group for containers.
   groupadd -g 22022 "$DRGROUP"
   adduser --disabled-password --gecos '' -u 22022 --gid 22022 "$DRUSER"

   mkdir -p "$ROOTPATH"   # ensure directrory exists.
   
   echo "Configuration complete: created druser and set up $ROOTPATH." >&2
}

#------------------------------------------------------------------------------------

# checkimage 
function checkimage {
   # Check mandatory files in image (global var IMAGENAME) before touching host. Is it a valid dr container?
   for CFILE in "${REQDFILES[@]}"; do
      docker run --rm -it "${IMAGENAME}" /bin/bash -c "command -v /dr/$CFILE >/dev/null 2>&1"
      if [ "$?" -ne 0 ]; then echo "${IMAGENAME} is not Docker Runner compatible. The script /dr/${CFILE} is missing.">&2 ; exit 1 ; fi
   done
   
   # Check running as druser.
   USERID=$(docker run --rm -it "${IMAGENAME}" /bin/bash -c "id -u | tr -d '\r\n'")
   if [ "$USERID" != "22022" ]; then echo "${IMAGENAME} is not Docker Runner compatible. Not running as druser (uid 22022). It's >>$USERID<<">&2 ; exit 1 ; fi   
   
   echo "${IMAGENAME} is dr compatible.">&2
}

#------------------------------------------------------------------------------------

# createlaunchscript
function createlaunchscript {
   local SCRIPTPATH="/usr/local/bin/${SERVICENAME}"
   cat <<EOF >"$SCRIPTPATH"
#!/bin/bash
dr ${SERVICENAME} "\$@"
EOF
   chmod a+x "$SCRIPTPATH"
}

#------------------------------------------------------------------------------------

# copydrfiles
function copydrfiles {
   # the ROOTPATH that the container will update.
   local DRBINPATH="${SERVICEPATH}/${SERVICEBINDIR}"
   if [ -d "${DRBINPATH}" ]; then
      rm -r "${DRBINPATH}"
   fi
   mkdir -p "${DRBINPATH}"
   chown "${DRUSER}:${DRGROUP}" "${DRBINPATH}"
   
   # assumes docker image does not use entrypoint. Could instead override entrypoint maybe.
   docker run --rm -it -v "${DRBINPATH}:/tempcopy" "${IMAGENAME}" /bin/bash -c "cp -a /dr/* /tempcopy/"                             
   if [ $? -ne 0 ]; then 
      echo "Failed to copy files.">&2 
      echo "You will need to reinstall the service.">&2
      rm -r "${SERVICEPATH}"
      exit 1
   fi  
   chown -R root:root "${DRBINPATH}"
   chmod -R a-w "${DRBINPATH}"
}

#------------------------------------------------------------------------------------

# initdrservice
function initSERVICEPATH {
   # can only call when service ROOTPATH not present (for safety)
   if [ -d "${SERVICEPATH}" ]; then
      echo "A service is already installed at ${SERVICEPATH}. Initialisation cancelled.">&2
      echo "You might want   dr update ${SERVICENAME}  instead.">&2
      exit 1
   fi

   copydrfiles

   # add standard dr config stuff.
   mkdir -p "${SERVICEPATH}/${DRCFGDIR}"
   echo "${IMAGENAME}" > "${SERVICEPATH}/${CFG_IMAGENAME}"
   echo "${SERVICENAME}" > "${SERVICEPATH}/${CFG_SERVICENAME}" 

   # Check mandatory files made it over to host okay from the container.
   for HFILE in "${REQDFILES[@]}"; do
      if [ ! -e "${SERVICEPATH}/${SERVICEBINDIR}/${HFILE}" ]; then 
         echo "Install failed - ${HFILE} is required" 
         rm -r "${SERVICEPATH}"
         exit 1
      fi
   done
}

#------------------------------------------------------------------------------------

# install
function install {   
   if [ -z "$IMAGENAME" ]; then echo "dr install requires IMAGENAME.">&2 ; exit 1 ; fi
   if [ -z "$SERVICENAME" ]; then echo "dr install requires SERVICENAME.">&2 ; exit 1 ; fi

   checkimage
   
   local DNAME="dr-install"

   # --- all four globals have been set.
   initSERVICEPATH
   
   # create the standard config volume container.
   docker volume create --name="dr-${SERVICENAME}-config" >/dev/null
   # set permissions on config volume
   docker run --name="$DNAME" -v "dr-${SERVICENAME}-config:/config" "${COPYIMAGE}" /bin/bash -c "chown druser:drgroup /config && date >> /config/install_date"
   docker rm "$DNAME" >/dev/null 
    
   # Run the install script, e.g. to create volume containers.
   # todo: tidy up return/exit codes!         
   bash "${SERVICEPATH}/${SERVICEBINDIR}/install" "${SERVICENAME}" "${IMAGENAME}"
   
   # allow direct execution of SERVICENAME without typing dr
   createlaunchscript
    
   # TODO: If we had errors then destroy everything!
   echo "Installation of service ${SERVICENAME} successful."
}

#------------------------------------------------------------------------------------

# destroy
function destroy {
   if [ -z "$SERVICENAME" ]; then die "dr destroy requires SERVICENAME to be set." ; fi
   if [ ! -d "$SERVICEPATH" ]; then echo "The service ${SERVICENAME} does not exist.">&2 ; showservices ; exit 1 ; fi
   
   local RVALD=0

   # if the install process created a destroy script then run it, e.g. to destroy volume containers.
   # todo: tidy up return/exit codes!         
   if [ -e "${SERVICEPATH}/${SERVICEBINDIR}/destroy" ]; then
      bash "${SERVICEPATH}/${SERVICEBINDIR}/destroy" "${SERVICENAME}" "${IMAGENAME}"
   else 
      RVALD=1
   fi      
   
   # remove volume container.
   docker volume rm "dr-${SERVICENAME}-config" >/dev/null
   
   # remove launch script
   if [ -e "/usr/local/bin/${SERVICENAME}" ]; then rm "/usr/local/bin/${SERVICENAME}" ; fi
   
   # clean up service ROOTPATH.
   rm -r "${SERVICEPATH}"
   
   exit $RVALD
}

#------------------------------------------------------------------------------------
# compress SOURCEFOLDER ARCHIVEFOLDER ARCHIVENAME [PASS]
function compress {
   local SOURCEFOLDER=$(realpath "$1" | tr -d '\r\n')
   if [ $? -ne 0 ]; then die "dr function compress: Couldn't find source path ${1}." ; fi
   local ARCHIVEFOLDER=$(realpath "$2" | tr -d '\r\n')
   if [ $? -ne 0 ]; then die "dr function compress: Couldn't find destination path ${2}." ; fi
   local ARCHIVEPATH="$ARCHIVEFOLDER/$3"
   local PASSCMD=""
   if [ -n "$4" ]; then PASSCMD="-p${4}"; fi
   
   tar cf - -C "$SOURCEFOLDER" . | 7za a -si "${PASSCMD}" "$ARCHIVEPATH" > /dev/null
   if [ $? -ne 0 ]; then die "Failed to create archive of $SOURCEFOLDER" ; fi
}

# decompress DESTFOLDER ARCHIVEFOLDER ARCHIVENAME [PASS]
function decompress {
   local DESTFOLDER=$(realpath "$1" | tr -d '\r\n')
   local ARCHIVEFOLDER=$(realpath "$2" | tr -d '\r\n')
   local ARCHIVEPATH="$ARCHIVEFOLDER/$3"

   if [ ! -e "$ARCHIVEPATH" ]; then die "dr function decompress: No such archive: $ARCHIVEPATH"; fi
   if [ ! -d "$DESTFOLDER" ]; then die "dr function decompress: Destination folder does not exist: $DESTFOLDER"; fi
   local PASSCMD=""
   if [ -n "$4" ]; then PASSCMD="-p${4}"; fi
   
   7za x -so "${PASSCMD}" "${ARCHIVEPATH}" | tar xf - -C "${DESTFOLDER}"
   if [ $? -ne 0 ]; then die "Failed to decompress archive $ARCHIVEPATH . The password may be incorrect!"; fi
}

# compressvolume VOLUMENAME ARCHIVEFOLDER ARCHIVENAME
function compressvolume {
   local VOLUMENAME="$1"
   local ARCHIVEFOLDER=$(realpath "$2" | tr -d '\r\n')
   if [ $? -ne 0 ]; then die "dr function compressvolume: Couldn't find destination path $2." ; fi
   local ARCHIVENAME="$3"
   local DCNAME="dr-compressvolume"

   docker run --name="${DCNAME}" \
      -v "${VOLUMENAME}:/vol" -v "${ARCHIVEFOLDER}:/archive" "${COPYIMAGE}" \
      /bin/bash -c "tar zcf /archive/${ARCHIVENAME} -C /vol ."
   docker rm "${DCNAME}" >/dev/null 
}

# decompressvolume VOLUMENAME ARCHIVEFOLDER ARCHIVENAME
function decompressvolume {
   local VOLUMENAME="$1"
   local ARCHIVEFOLDER=$(realpath "$2" | tr -d '\r\n')
   local ARCHIVENAME="$3"
   if [ ! -e "$ARCHIVEFOLDER/$ARCHIVENAME" ]; then die "dr function decompressvolume: Couldn't find archive $ARCHIVENAME" ; fi
   local DCNAME="dr-decompressvolume"

   # destroy any pre-existing data!
   docker volume rm "${VOLUMENAME}" >/dev/null
   docker volume create --name="${VOLUMENAME}" >/dev/null
   docker run --name="${DCNAME}" \
      -v "${VOLUMENAME}:/vol" -v "${ARCHIVEFOLDER}:/archive" "${COPYIMAGE}" \
      /bin/bash -c "tar zxf /archive/${ARCHIVENAME} -C /vol"
   docker rm "${DCNAME}" >/dev/null 
}

#------------------------------------------------------------------------------------

# backup BACKUPFILE
function backup {
   if [ -z "$1" ]; then die "No BACKUPFILE was specified." ; fi
   local BACKUPFILE=$(realpath "$1" | tr -d '\r\n')
   if [ -e "$BACKUPFILE" ]; then die "$BACKUPFILE already exists. Aborting." ; fi
   
   local TEMPROOT="$(mktemp -d)"
   local TEMPPARENT="${TEMPROOT}/backup"
   local TEMPF="${TEMPPARENT}/drbackup"
   mkdir -p "$TEMPF"
   local TEMPC="${TEMPPARENT}/containerbackup"
   mkdir -p "$TEMPC"
   
   # for convenience, stick teh imagename in the tempparent folder
   echo "${IMAGENAME}" > "$TEMPPARENT/imagename.txt"
   
   # back up our configuration ROOTPATH.
   compress "$SERVICEPATH/${DRCFGDIR}" "${TEMPF}" "${BACKUP_HOSTZIP}"
   
   # back up our volume container (dr-${SERVICENAME}-config).
   compressvolume "dr-${SERVICENAME}-config" "${TEMPF}" "${BACKUP_VOLZIP}"
   
   # call through to container to backup anything there in a subfolder.
   SCRIPTTORUN="${SERVICEPATH}/${SERVICEBINDIR}/backup"
   bash "$SCRIPTTORUN" "$SERVICENAME" "$IMAGENAME" "$TEMPC"
      
   # Compress everything with password
   compress "$TEMPPARENT" "$TEMPROOT" "${BACKUP_MAIN}" "$PASS"
   mv "${TEMPROOT}/${BACKUP_MAIN}" "$BACKUPFILE"

   rm -r "${TEMPROOT}"
   echo " ">&2
   if [ -z "$PASS" ]; then "WARNING: No password supplied. Backup is not encrypted!">&2 ; fi
   echo "Backed up to $BACKUPFILE succesfully.">&2
}

#------------------------------------------------------------------------------------

# restore BACKUPFILE
function restore {
   if [ -z "$1" ]; then die "No BACKUPFILE was specified." ; fi
   local BACKUPFILE=$(realpath "$1" | tr -d '\r\n')
   if [ ! -e "$BACKUPFILE" ]; then die "$BACKUPFILE doesn't exist. Aborting." ; fi
   if [ -e "$SERVICEPATH" ]; then die "$SERVICENAME exists - destroy it before restoring from backup." ; fi
   
   local TEMPROOT="$(mktemp -d)"
   local TEMPPARENT="${TEMPROOT}/backup"
   local TEMPF="${TEMPPARENT}/drbackup"
   mkdir -p "$TEMPF"
   local TEMPC="${TEMPPARENT}/containerbackup"
   mkdir -p "$TEMPC"
   
   # decompress the main backup
   cp "$BACKUPFILE" "${TEMPROOT}/${BACKUP_MAIN}"
   decompress "$TEMPPARENT" "$TEMPROOT" "$BACKUP_MAIN" "$PASS"
      
   # check backup has key files.
   local KEYFILES=("${TEMPF}/${BACKUP_HOSTZIP}" "${TEMPF}/${BACKUP_VOLZIP}" "${TEMPPARENT}/imagename.txt")
   for NEEDEDFILE in "${KEYFILES[@]}"; do
      if [ ! -e "$NEEDEDFILE" ]; then die "Backup corrupt. Missing ${NEEDEDFILE}."; fi
   done
   
   # set IMAGENAME - the only missing global var.
   IMAGENAME=$(<"$TEMPPARENT/imagename.txt")

   # now can install base service
   install
        
   # restore our volume container (dr-${SERVICENAME}-config), first destroying the one install just created.
   decompressvolume "dr-${SERVICENAME}-config" "${TEMPF}" "${BACKUP_VOLZIP}"

   # restore our configuration, first removing the one install just created.
   rm -r "${SERVICEPATH}/${DRCFGDIR}"
   mkdir "${SERVICEPATH}/${DRCFGDIR}"
   decompress "${SERVICEPATH}/${DRCFGDIR}" "${TEMPF}" "${BACKUP_HOSTZIP}"
   
   # call through to container to restore anything there.
   SCRIPTTORUN="${SERVICEPATH}/${SERVICEBINDIR}/restore"
   bash "$SCRIPTTORUN" "$SERVICENAME" "$IMAGENAME" "$TEMPC"
   
   echo "Service ${SERVICENAME} has been restored successfully."
}

#------------------------------------------------------------------------------------


# retriveROOTPATH
function retrieveROOTPATH {
   DIRERR="Run   dr configure ROOTPATH   before any other commands."
   if [ ! -d "$DRETCDIR" ]; then die "$DIRERR"; fi
   ROOTPATH=$(<"${CFG_ROOTPATH}")
   if [ -z "$ROOTPATH" ]; then die "$DIRERR"; fi
   if [ ! -d "$ROOTPATH" ]; then die "$DIRERR"; fi
}

#------------------------------------------------------------------------------------

# setglobals
function setglobals {
   # expects SERVICENAME to be set.
   if [ -z "${SERVICENAME}" ]; then 
      die "SERVICENAME has not been set." 
   fi
   retrieveROOTPATH

   SERVICEPATH="${ROOTPATH}/${SERVICENAME}"
   if [ ! -d "$SERVICEPATH" ]; then echo "The service ${SERVICENAME} does not exist.">&2 ; showservices ; exit 1 ; fi

   if [ ! -e "${SERVICEPATH}/${CFG_IMAGENAME}" ]; then die "Error - ${CFG_IMAGENAME} doesn't exist."; fi
   IMAGENAME=$(<"${SERVICEPATH}/${CFG_IMAGENAME}")
   if [ -z "$IMAGENAME" ]; then die "Error - ${CFG_IMAGENAME} is empty." ; fi
}


function showservicehelp {
   local HELPSCRIPT="${SERVICEPATH}/${SERVICEBINDIR}/help"
   if [ -e "${HELPSCRIPT}" ]; then
      bash "${HELPSCRIPT}" "${SERVICENAME}" "${IMAGENAME}"
      exit 0
   else
      showservices
      echo " ">&2
      die "Service ${SERVICENAME} does not exist."
   fi
}

#------------------------------------------------------------------------------------

# ███╗   ███╗ █████╗ ██╗███╗   ██╗
# ████╗ ████║██╔══██╗██║████╗  ██║
# ██╔████╔██║███████║██║██╔██╗ ██║
# ██║╚██╔╝██║██╔══██║██║██║╚██╗██║
# ██║ ╚═╝ ██║██║  ██║██║██║ ╚████║
# ╚═╝     ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝

function main {                                

   if [ "$EUID" -ne 0 ]; then echo "Please run as root" ; exit 1 ; fi
   if ! command_exists docker ; then die "Requires docker to be installed." ; fi
   if [ "$(uname -rv | grep -c Debian)" -eq 0 ]; then die "Built for Debian only." ; fi

   # Check basic commands are available
   COMMANDS=(gpg wget md5sum 7z 7za)
   for NEEDEDCMD in "${COMMANDS[@]}"; do
   if ! command_exists "${NEEDEDCMD}" ; then die "${NEEDEDCMD} is not installed." ; fi
   done

   # defines $ROOTPATH  $DRSERVICESPATH  $SUPPORTIMAGE
   initglobals

   # check special commands with no SERVICENAME needed
   if [ "$#" -eq 0 ]; then 
      showusage
      showservices
      exit 0
   elif [ "$1" = "clean" ]; then
      docker run --rm -v /var/run/docker.sock:/var/run/docker.sock spotify/docker-gc
      exit 0
   elif [ "$1" = "list" ]; then
      showservices 
      exit 0
   fi     

   # all other commands have SERVICENAME as first argument.
   SERVICENAME="$1"
   SERVICEPATH="${DRSERVICESPATH}/${SERVICENAME}"
   SERVICECFGPATH="${SERVICEPATH}/${SERVICECFGFILE}"

   # read in SERVICEIMAGENAME from config file if present.
   if [ -e "$SERVICECFGPATH" ]; then
      . "$SERVICECFGPATH"
      IMAGENAME="$SERVICEIMAGENAME"
   fi

   # dr SERVICE with no other params.
   if [ "$#" -eq 1 ]; then
      showservicehelp
   fi

   # get the command to run and shift so $@ is the args.
   USERCOMMAND="$2"
   shift 2

   case "$USERCOMMAND" in
      install)
         if [ "$#" -eq 1 ]; then
            IMAGENAME="$1"
            install
         else
            dieusage "dr SERVICENAME install IMAGENAME"
         fi
         ;;

      *)         
         SCRIPTTORUN="${SERVICEPATH}/${SERVICEBINDIR}/${USERCOMMAND}"
         if [ -e "${SCRIPTTORUN}" ]; then
            bash "${SCRIPTTORUN}" "${SERVICENAME}" "${IMAGENAME}" "$@"
         else
            showservicehelp
         fi
         ;;


   esac

   # case "$CMD" in
   #    configure)
   #       if [ "$1" ]; then
   #          ROOTPATH="$1"
   #          configure
   #       else
   #          dieusage "dr configure ROOTPATH"
   #       fi
   #       ;;


         
   #    update)
   #       if [ "$1" ]; then
   #          SERVICENAME="$1"
   #          setglobals
   #          copydrfiles
   #       else
   #          dieusage "dr update SERVICENAME"
   #       fi         
   #       ;;
         
   #    # dr backup SERVICENAME BACKUPFILE
   #    backup)
   #       if [ "$1" ] && [ "$2" ]; then
   #          SERVICENAME="$1"
   #          setglobals
   #          backup "$2"
   #       else
   #          dieusage "[PASS=?] dr backup SERVICENAME BACKUPFILE"
   #       fi
   #       ;;
      
   #    # dr restore SERVICENAME BACKUPFILE
   #    restore)
   #       if [ "$1" ] && [ "$2" ]; then
   #          SERVICENAME="$1"
   #          retrieveROOTPATH
   #          SERVICEPATH="${ROOTPATH}/${SERVICENAME}"
   #          restore "$2"
   #       else
   #          dieusage "[PASS=?] dr restore SERVICENAME BACKUPFILE"
   #       fi
   #       ;;
      
   #    #--------------------------         
         
   #    destroy)
   #       if [ "$1" ]; then
   #          SERVICENAME="$1" ; shift
   #          setglobals
   #          destroy 
   #       else
   #          dieusage "dr destroy SERVICENAME"
   #       fi
   #       ;;
         
      
   #    *)
   #       # check if CMD matches a service. If so run the appropriate script.
   #       # format:   dr SERVICENAME COMMAND ARGS
   #       SERVICENAME="$CMD"
   #       setglobals
         
   #       SUBCOMMAND="$1" ; shift
   #       SCRIPTTORUN="${SERVICEPATH}/${SERVICEBINDIR}/${SUBCOMMAND}"
   #       if [ -n "$SUBCOMMAND" ] && [ -e "${SCRIPTTORUN}" ]; then
   #          bash "${SCRIPTTORUN}" "${SERVICENAME}" "${IMAGENAME}" "$@"
   #       else
   #          bash "${SERVICEPATH}/${SERVICEBINDIR}/help" "${SERVICENAME}" "${IMAGENAME}"
   #       fi
   #       ;;
   # esac

}


main "$@"
