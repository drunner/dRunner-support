#!/bin/bash
set -o nounset

# ██████╗  ██████╗  ██████╗██╗  ██╗███████╗██████╗     ██████╗ ██╗   ██╗███╗   ██╗███╗   ██╗███████╗██████╗ 
# ██╔══██╗██╔═══██╗██╔════╝██║ ██╔╝██╔════╝██╔══██╗    ██╔══██╗██║   ██║████╗  ██║████╗  ██║██╔════╝██╔══██╗
# ██║  ██║██║   ██║██║     █████╔╝ █████╗  ██████╔╝    ██████╔╝██║   ██║██╔██╗ ██║██╔██╗ ██║█████╗  ██████╔╝
# ██║  ██║██║   ██║██║     ██╔═██╗ ██╔══╝  ██╔══██╗    ██╔══██╗██║   ██║██║╚██╗██║██║╚██╗██║██╔══╝  ██╔══██╗
# ██████╔╝╚██████╔╝╚██████╗██║  ██╗███████╗██║  ██║    ██║  ██║╚██████╔╝██║ ╚████║██║ ╚████║███████╗██║  ██║
# ╚═════╝  ╚═════╝  ╚═════╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝    ╚═╝  ╚═╝ ╚═════╝ ╚═╝  ╚═══╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝
#                                                                                                          
#                                                                                                          
#  manage docker containers in a simple and consistent way.
#  
#  See:
#    https://github.com/j842/dr
#
# ------------------------------------------------------------------

# MYDIR - the directory this script is in and BUILDTIME - time image built.
readonly MYDIR=$( dirname "$(readlink -f "$0")" )
if [ ! -e "${MYDIR}/buildtime" ]; then BUILDTIME="BROKEN BUILD"
else . "${MYDIR}/buildtime"
fi

# Other global constanst from dr-install in this file.
readonly DR_CFG_FILE="/etc/dr/dr.cfg"

# Global constants.
readonly REQDFILES=("install" "destroy" "backup" "restore" "help" "enter")
readonly COPYIMAGE="j842/dr-baseimage-alpine"

readonly BACKUP_MAIN="backup.tar.7z"

#------------------------------------------------------------------------------------

# die MESSAGE 
function die {
   if [ -n "$1" ]; then
      echo "$1" <&2
   else
      echo "Unexpected error. Exiting."<&2
   fi
   exit 1
}
function dieusage {
   echo "Usage:">&2
   die "   $1"
}

#------------------------------------------------------------------------------------

function volexists {
  docker volume ls | grep "$1" > /dev/null
}

#------------------------------------------------------------------------------------

function checkdir {
   if [ -z "$1" ]; then die "Installation broken. Config file ${DR_CFG_FILE} doesn't set $2."; fi
   if [ ! -d "$1" ]; then die "Installation broken. $2 is set to $1 but it doesn't exist."; fi
}

#------------------------------------------------------------------------------------

function initglobals {
   # defines ROOTPATH, DRSERVICESPATH, SUPPORTIMAGE, DRBINPATH
   source "${DR_CFG_FILE}"
   
   # Check basic directories are okay
   checkdir "${ROOTPATH}" "ROOTPATH"
   checkdir "${DRSERVICESPATH}" "DRSERVICESPATH"
   checkdir "${DRBINPATH}" "DRBINPATH"
   
   readonly SUPPORTPATH="${DRBINPATH}/support"
}

#------------------------------------------------------------------------------------

# serviceline SERVICE SHORTHELP
function serviceline {
   printf "   %-15s - %-55s\n" "$1" "$2"
}

#------------------------------------------------------------------------------------

# showservices
function showservices {
   # list available services. 
   echo "AVAILABLE SERVICES"
   find "$DRSERVICESPATH" -maxdepth 1 -mindepth 1 -type d | while read SPATH; do 
      if [ -e "${SPATH}/bin/_variables" ]; then
         source "${SPATH}/bin/_variables"
         serviceline "${SPATH##*/}" "$IMAGENAME"
      else
         serviceline "${SPATH##*/}" "Broken service"
      fi
   done
}

#------------------------------------------------------------------------------------

# showusage
function showusage {
cat <<EOF >&2

NAME
   dr - docker runner

VERSION
   ${BUILDTIME}
   
SYNOPSIS
   dr clean
   dr list
   dr update
   
   [PASS=?] dr SERVICENAME backup BACKUPFILE
   [PASS=?] dr SERVICENAME restore BACKUPFILE
   dr SERVICENAME install IMAGENAME
   dr SERVICENAME update
   dr SERVICENAME destroy
   
   dr SERVICENAME
   dr SERVICENAME enter
   dr SERVICENAME COMMAND ARGS
   
   Once SERVICENAME is installed you can call it directly, e.g.
   SERVICENAME update
   This convenience just calls through to  dr SERVICENAME update .

DESCRIPTION
   Provides a standard way to manage and run containers supporting dr.
   Intended to be used both manually and via Ansible.
   See https://github.com/j842/dr
   
EXIT CODE
   0   - success
   1   - error
   3   - no changes made
   
EOF
}

#------------------------------------------------------------------------------------

# command_exists
function command_exists { command -v "$1" >/dev/null 2>&1 ; }

#------------------------------------------------------------------------------------

# getUSERID
function getUSERID {
   USERID=$(docker run --rm -it "${IMAGENAME}" /bin/bash -c "id -u | tr -d '\r\n'")
}


#------------------------------------------------------------------------------------

# destroy
# destroys everything we can about a service!
function destroy {   
   if [ -v SERVICEVARIABLESPATH ] && [ -e "$SERVICEVARIABLESPATH" ]; then
      source "$SERVICEVARIABLESPATH"
   fi   
   
   # call destroy in service.
   if [ -v SERVICEBINPATH ] && [ -e "${SERVICEBINPATH}/destroy" ]; then 
      echo "Calling destroy from within service."
      bash "${SERVICEBINPATH}/destroy"
   fi
   
   # remove volume container.
   if [ -v DOCKERVOLS ]; then
      for VOLNAME in "${DOCKERVOLS[@]}"; do      
         echo "Destroying volume $VOLNAME."
         docker volume rm "$VOLNAME" >/dev/null
      done
   fi
   
   # remove launch script
   if [ -v SERVICENAME ] && [ -e "/usr/local/bin/${SERVICENAME}" ]; then 
      echo "Removing command $SERVICENAME."
      rm "/usr/local/bin/${SERVICENAME}"
   fi
   
   # delete service directoy.
   if [ -v SERVICEPATH ] && [ -d "${SERVICEPATH}" ]; then
      echo "Removing all service files from ${SERVICEPATH}."
      rm -r "${SERVICEPATH}"
   fi
   
   if [ -v SERVICENAME ]; then
      echo "Service $SERVICENAME has been destroyed."
   else
      echo "No service specified."
   fi
}

#------------------------------------------------------------------------------------

# install_checkimage 
function install_checkimage {
   if [ ! -e "${SUPPORTPATH}/validator" ]; then
      die "Missing dr file: ${SUPPORTPATH}/validator"
   fi
   docker run --rm -v "${SUPPORTPATH}:/support" "${IMAGENAME}" /bin/bash -c "/support/validator"
   if [ "$?" -ne 0 ]; then 
      die "Unable to continue because ${IMAGENAME} is not Docker Runner compatible."
   fi
   
   echo "${IMAGENAME} is dr compatible.">&2
}

#------------------------------------------------------------------------------------

# install_createlaunchscript
function install_createlaunchscript {
   local SCRIPTPATH="/usr/local/bin/${SERVICENAME}"
   cat <<EOF >"$SCRIPTPATH"
#!/bin/bash
dr ${SERVICENAME} "\$@"
EOF
   chmod a+x "$SCRIPTPATH"
}

#------------------------------------------------------------------------------------

# install_checkReqdFiles
function install_checkReqdFiles {
   # Check mandatory files made it over to host okay from the container.
   for HFILE in "${REQDFILES[@]}"; do
      if [ ! -e "${SERVICEBINPATH}/${HFILE}" ]; then 
         echo "Install failed - ${HFILE} is required but wasn't copied from image ${IMAGE}." 
         rm -r "${SERVICEPATH}"
         exit 1
      fi
   done
}

#------------------------------------------------------------------------------------

# install_createVolumes
function install_createVolumes {
   # create the necessary volume containers.
   local DNAME="dr-install-volcreate"
   for VOLNAME in "${DOCKERVOLS[@]}"; do      
      volexists "$VOLNAME"
      if [ $? -ne 0 ]; then 
         echo "A docker volume already exists for: $VOLNAME. Reusing it.";
      else
         docker volume create --name="$VOLNAME" >/dev/null
         # set permissions on config volume
         docker run --name="$DNAME" -v "dr-${SERVICENAME}-config:/config" "${COPYIMAGE}" \
            /bin/bash -c "chown ${USERID}:root /config && date >> /config/install_date"
         docker rm "$DNAME" >/dev/null 
      fi
   done     
}


#------------------------------------------------------------------------------------

# recreateServiceBinPath
# called by both install and SERVICE update.
function recreateServiceBinPath {   
   # the directory that the container will update.
   if [ -d "${SERVICEBINPATH}" ]; then rm -r "${SERVICEBINPATH}" ; fi
   mkdir -p "${SERVICEBINPATH}"

   # we need the user id for the account that the image uses.
   getUSERID
   if [ -z "$USERID" ] || [ "${USERID}" -eq 0 ]; then die "Internal error - USERID for image is not a normal user." ; fi

   # allow the container to write into this folder.
   chown "${USERID}" "${SERVICEBINPATH}"
   
   # assumes docker image does not use entrypoint. Could instead override entrypoint maybe.
   docker run --rm -it -v "${SERVICEBINPATH}:/tempcopy" "${IMAGENAME}" /bin/bash -c "cp -r /dr/* /tempcopy/"                             
   if [ $? -ne 0 ]; then 
      echo "Failed to copy files.">&2 
      echo "You will need to reinstall the service.">&2
      rm -r "${SERVICEPATH}"
      exit 1
   fi  
   # tighten up permissions
   chown -R root:root "${SERVICEBINPATH}"
   chmod -R a-w "${SERVICEBINPATH}"
   
   # create _variables file.
   if [ ! -e "${SERVICEBINPATH}/volumes" ]; then die "Missing volumes file for $SERVICENAME" ; fi
   source "${SERVICEBINPATH}/volumes"
   if [ ! -v VOLUMES ]; then die "volumes file did not contain a volumes definition!" ; fi
   DOCKERVOLS=( )
   DOCKEROPTS=( )
   for i in "${!VOLUMES[@]}"; do
      DOCKERVOLS[$((i))]="dr-${SERVICENAME}-${VOLUMES[i]//[![:alnum:]]/}"
      DOCKEROPTS[$((2*i))]="-v"
      DOCKEROPTS[$((2*i+1))]="${DOCKERVOLS[i]}:${VOLUMES[i]}"
   done
   
   local DATESTAMP="$(TZ=Pacific/Auckland date -u +"%a, %d %b %Y %X %z")"
   printf -v STR_DOCKERVOLS "\"%s\" " "${DOCKERVOLS[@]}"
   printf -v STR_DOCKEROPTS "\"%s\" " "${DOCKEROPTS[@]}"
   printf -v STR_VOLUMES "\"%s\" " "${VOLUMES[@]}"
   cat <<EOF >"${SERVICEVARIABLESPATH}"
# Auto generated by Docker Runner
# ${DATESTAMP}
VOLUMES=(${VOLUMES[@]})
DOCKERVOLS=(${DOCKERVOLS[@]})
DOCKEROPTS=(${DOCKEROPTS[@]})
SERVICENAME="${SERVICENAME}"
IMAGENAME="${IMAGENAME}"
INSTALLTIME="${DATESTAMP}"
EOF
}

#------------------------------------------------------------------------------------

# install
# global variables ready: ROOTPATH, DRSERVICESPATH, SUPPORTIMAGE, SERVICENAME, SERVICEPATH, SERVICEVARIABLESPATH, IMAGENAME
function install {   
   if [ -z "$IMAGENAME" ]; then echo "dr install requires IMAGENAME.">&2 ; exit 1 ; fi
   if [ -z "$SERVICENAME" ]; then echo "dr install requires SERVICENAME.">&2 ; exit 1 ; fi

   if [ -d "${SERVICEPATH}" ]; then
      echo "A service is already installed at ${SERVICEPATH}. Initialisation cancelled.">&2
      echo "You might want   dr ${SERVICENAME} update  instead.">&2
      exit 1
   fi

   ( # SUBSHELL
     # set -e
      
      install_checkimage
      recreateServiceBinPath
      install_checkReqdFiles
      install_createVolumes
      install_createlaunchscript
       
      # Finally run the install script in the service.         
      bash "${SERVICEBINPATH}/install" "${SERVICENAME}" "${IMAGENAME}"      
   )
   if [ $? -ne 0 ]; then
      destroy
      die "Installation failed. System returned to clean state."
   fi
    
   # TODO: If we had errors then destroy everything!
   echo "Installation of service ${SERVICENAME} successful."
}

#------------------------------------------------------------------------------------

# update
function update {
   # use the container to get the latest dr-install script.
   local TEMPDIR="$(mktemp -d)"
   docker run -i -t --name="get-dr-install" -v "${TEMPDIR}:/tempdir" \
               "${SUPPORTIMAGE}" get-dr-install "/tempdir"
   local RVAL="$?"
   docker rm "get-dr-install" >/dev/null 2>&1

   if [ "$RVAL" -ne 0 ]; then die "Unable to get dr-install.">&2 ; fi
   if [ ! -e "${TEMPDIR}/dr-install" ]; then die "dr-install mysteriously missing.">&2 ; fi
   
   # run it to update the installation.
   bash "${TEMPDIR}/dr-install" "${ROOTPATH}"
   rm -r "${TEMPDIR}"
   exit 0
}


#------------------------------------------------------------------------------------

# backup BACKUPFILE
# global variables ready: ROOTPATH, DRSERVICESPATH, SUPPORTIMAGE, SERVICENAME, SERVICEPATH, SERVICEVARIABLESPATH, IMAGENAME
function backup {
   if [ -z "$1" ]; then die "No BACKUPFILE was specified." ; fi
   local BACKUPFILE=$(realpath "$1" | tr -d '\r\n')
   if [ -e "$BACKUPFILE" ]; then die "$BACKUPFILE already exists. Aborting." ; fi
   
   local TEMPROOT="$(mktemp -d)"
   
   ( # SUBSHELL so we can tidy up easily if it goes wrong.
      # bail if any command returns an error!
      set -e
      
      local TEMPPARENT="${TEMPROOT}/backup"
      local TEMPF="${TEMPPARENT}/drbackup"
      mkdir -p "$TEMPF"
      local TEMPC="${TEMPPARENT}/containerbackup"
      mkdir -p "$TEMPC"
      
      # back up the service variables (SERVICEVARIABLESPATH) to the tempparent folder
      cp "$SERVICEVARIABLESPATH" "$TEMPPARENT"

      # call through to container to backup anything there in a subfolder.
      # important this is called before backing up any volume containers, as
      # it might put stuff in them.
      getUSERID
      chown "${USERID}" "${TEMPC}"
      bash "${SERVICEBINPATH}/backup" "$TEMPC"
                  
      # back up our volume containers
      for VOLNAME in "${DOCKERVOLS[@]}"; do      
         volexists "$VOLNAME"
         if [ $? -ne 0 ]; then die "A docker volume required for the backup was missing: $VOLNAME"; fi
         "${SUPPORTPATH}/compress" "$VOLNAME" "${TEMPF}" "${VOLNAME}.tar.7z"
      done      
      
      # Compress everything with password
      "${SUPPORTPATH}/compress" "$TEMPPARENT" "$TEMPROOT" "${BACKUP_MAIN}"
      mv "${TEMPROOT}/${BACKUP_MAIN}" "$BACKUPFILE"
   )
   RVAL="$?" 
   rm -r "${TEMPROOT}"
   if [ $RVAL -ne 0 ]; then die "Backup failed. Temp files have been removed." ; fi
   
   echo " ">&2
   echo "Backed up to $BACKUPFILE succesfully.">&2
}

#------------------------------------------------------------------------------------

# restore BACKUPFILE
function restore {
   if [ -z "$1" ]; then die "No BACKUPFILE was specified." ; fi
   local BACKUPFILE=$(realpath "$1" | tr -d '\r\n')
   if [ ! -e "$BACKUPFILE" ]; then die "$BACKUPFILE doesn't exist. Aborting." ; fi
   if [ -e "$SERVICEPATH" ]; then die "$SERVICENAME exists - destroy it before restoring from backup." ; fi
   
   local TEMPROOT="$(mktemp -d)"
   
   ( # SUBSHELL so we can tidy up easily if it goes wrong.
      # bail if any command returns an error!
      set -e

      local TEMPPARENT="${TEMPROOT}/backup"
      mkdir -p "$TEMPPARENT"
      local TEMPF="${TEMPPARENT}/drbackup"
      local TEMPC="${TEMPPARENT}/containerbackup"
      
      # decompress the main backup
      cp "$BACKUPFILE" "${TEMPROOT}/${BACKUP_MAIN}"
      "${SUPPORTPATH}/decompress" "$TEMPPARENT" "$TEMPROOT" "$BACKUP_MAIN"
         
      # check backup has key files.
      if [ ! -e "$TEMPC" ]; then die "Backup corrupt. Missing ${TEMPC}."; fi
      for NEEDEDFILE in "${DOCKERVOLS[@]}"; do
         if [ ! -e "${NEEDEDFILE}.tar.7z" ]; then die "Backup corrupt. Missing backup file for docker volume ${NEEDEDFILE}."; fi
      done
      
      # set IMAGENAME - the only missing global var.
      . "${TEMPPARENT}/_variables"

      # now can install base service
      install
         
      # restore volumes.
      for VOLNAME in "${DOCKERVOLS[@]}"; do      
         "${SUPPORTPATH}/decompress" "$VOLNAME" "${TEMPF}" "${VOLNAME}.tar.7z"
      done

      # We restore our backed up _variables.
      cp "${TEMPPARENT}/_variables" "$SERVICEVARIABLESPATH" 
      
      # call through to container to restore its backup in TEMPC. Imporant this is the last step,
      # so it can use any docker volumes, the _variables file etc.
      bash "${SERVICEBINPATH}/restore" "$TEMPC"
   )
   RVAL="$?"
   rm -r "${TEMPROOT}"   
   if [ $RVAL -ne 0 ]; then die "Restore failed. Temp files have been removed." ; fi
      
   echo "The backup ${BACKUPFILE##*/} has been restored to ${SERVICENAME}."
   
   # our globals haven't been updated outside the subshell (IMAGENAME not set for example) so exit to be safe.
   exit 0
}

#------------------------------------------------------------------------------------

function showservicehelp {
   local HELPSCRIPT="${SERVICEBINPATH}/help"
   if [ -e "${SERVICEVARIABLESPATH}" ] && [ -e "$HELPSCRIPT" ]; then
      source "$SERVICEVARIABLESPATH"
      bash "${HELPSCRIPT}" "${SERVICENAME}" "${IMAGENAME}"
      exit 0
   else
      showservices
      echo " ">&2
      die "Service ${SERVICENAME} does not exist."
   fi
}

#------------------------------------------------------------------------------------

# ███╗   ███╗ █████╗ ██╗███╗   ██╗
# ████╗ ████║██╔══██╗██║████╗  ██║
# ██╔████╔██║███████║██║██╔██╗ ██║
# ██║╚██╔╝██║██╔══██║██║██║╚██╗██║
# ██║ ╚═╝ ██║██║  ██║██║██║ ╚████║
# ╚═╝     ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝

function main {                                

   if [ "$EUID" -ne 0 ]; then echo "Please run as root" ; exit 1 ; fi
   if ! command_exists docker ; then die "Requires docker to be installed." ; fi
   if [ "$(uname -rv | grep -c Debian)" -eq 0 ]; then die "Built for Debian only." ; fi

   # defines ROOTPATH,  DRSERVICESPATH,  SUPPORTIMAGE,  DRBINPATH, SUPPORTPATH
   initglobals

   # check special commands with no SERVICENAME needed
   if [ "$#" -eq 0 ]; then 
      showusage
      showservices
      exit 0
   elif [ "$1" = "clean" ]; then
      docker run --rm -v /var/run/docker.sock:/var/run/docker.sock spotify/docker-gc
      exit 0
   elif [ "$1" = "list" ]; then
      showservices 
      exit 0
   elif [ "$1" = "update" ]; then
      update
      exit 0
   fi     

   # all other commands have SERVICENAME as first argument.
   SERVICENAME="$1"
   readonly SERVICEPATH="${DRSERVICESPATH}/${SERVICENAME}"
   readonly SERVICEBINPATH="${SERVICEPATH}/bin"
   readonly SERVICEVARIABLESPATH="${SERVICEBINPATH}/_variables"

   # dr SERVICE with no other params.
   if [ "$#" -eq 1 ]; then
      showservicehelp
   fi

   # get the command to run and shift so $@ is the args.
   USERCOMMAND="$2"
   shift 2

   # HANDLE COMMANDS FOR A SERVICE THAT MIGHT BE BROKEN OR NOT EXIST YET. 
   case "$USERCOMMAND" in
      install)
         if [ "$#" -eq 1 ]; then
            IMAGENAME="$1"
            install
            echo " ">&2
            showservicehelp
            exit 0
         else
            dieusage "dr SERVICENAME install IMAGENAME"
         fi
         ;;

      restore)
         if [ "$#" -eq 1 ]; then
            restore "$1"
            exit 0
         else
            dieusage "[PASS=?] dr SERVICENAME restore BACKUPFILE"
         fi
         ;;

      destroy)
         destroy 
         exit 0
         ;;         

      esac
   
   # -------------------------------------
   
   # If we've reached here then the service is expected to be okay.
   # Read in _variables from the service.
   if [ ! -d "$SERVICEPATH" ]; then showservices ; die "Service $SERVICENAME does not exist." ; fi
   if [ ! -e "$SERVICEVARIABLESPATH" ]; then die "Service ${SERVICENAME} is corrupt (missing its _variables file)." ; fi
   source "$SERVICEVARIABLESPATH"

   # HANDLE COMMANDS FOR AN EXISTING SERVICE
   case "$USERCOMMAND" in
      update)
         recreateServiceBinPath
         ;;
                  
      backup)
         if [ "$#" -eq 1 ]; then
            backup "$1"
         else
            dieusage "[PASS=?] dr SERVICENAME backup BACKUPFILE"
         fi
         ;;

      *)         
         SCRIPTTORUN="${SERVICEBINPATH}/${USERCOMMAND}"
         if [ -e "${SCRIPTTORUN}" ]; then
            bash "${SCRIPTTORUN}" "${SERVICENAME}" "${IMAGENAME}" "$@"
         else
            showservicehelp
         fi
         ;;

   esac     
}

#--------------------------------------------------------------------------
main "$@"
