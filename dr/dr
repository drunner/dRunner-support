#!/bin/bash
set -o nounset


# ██████╗  ██████╗  ██████╗██╗  ██╗███████╗██████╗     ██████╗ ██╗   ██╗███╗   ██╗███╗   ██╗███████╗██████╗ 
# ██╔══██╗██╔═══██╗██╔════╝██║ ██╔╝██╔════╝██╔══██╗    ██╔══██╗██║   ██║████╗  ██║████╗  ██║██╔════╝██╔══██╗
# ██║  ██║██║   ██║██║     █████╔╝ █████╗  ██████╔╝    ██████╔╝██║   ██║██╔██╗ ██║██╔██╗ ██║█████╗  ██████╔╝
# ██║  ██║██║   ██║██║     ██╔═██╗ ██╔══╝  ██╔══██╗    ██╔══██╗██║   ██║██║╚██╗██║██║╚██╗██║██╔══╝  ██╔══██╗
# ██████╔╝╚██████╔╝╚██████╗██║  ██╗███████╗██║  ██║    ██║  ██║╚██████╔╝██║ ╚████║██║ ╚████║███████╗██║  ██║
# ╚═════╝  ╚═════╝  ╚═════╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝    ╚═╝  ╚═╝ ╚═════╝ ╚═╝  ╚═══╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝
#                                                                                                          
#                                                                                                          
#  manage docker containers in a simple and consistent way.
#  
#  See:
#    https://github.com/j842/dr
#
# ------------------------------------------------------------------


# Other global constanst from dr-install in this file.
readonly DR_CFG_FILE="/etc/dr/dr.cfg"

# Global constants.
readonly DRBINPATH="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

readonly SERVICECFGFILE="service.cfg"
readonly REQDFILES=("install" "destroy" "backup" "restore" "help" "enter" )
readonly COPYIMAGE="j842/dr-baseimage-alpine"

readonly BACKUP_HOSTZIP="config_host.tar.7z"
readonly BACKUP_VOLZIP="config_volume_container.tar.7z"
readonly BACKUP_MAIN="backup.tar.7z"
   
# Global variables
SERVICENAME=""
DIRECTORY=""  
DIRSERVICE=""
IMAGENAME=""



#------------------------------------------------------------------------------------

# die MESSAGE 
function die {
   if [ -n "$1" ]; then
      echo "$1" <&2
   else
      echo "Unexpected error. Exiting."<&2
   fi
   exit 1
}
function dieusage {
   echo "Usage:">&2
   die "   $1"
}

#------------------------------------------------------------------------------------

function checkdir {
   if [ -z "$1" ]; then die "Installation broken. Config file ${DR_CFG_FILE} doesn't set $2."; fi
   if [ ! -d "$1" ]; then die "Installation broken. $2 is set to $1 but it doesn't exist."; fi
}

function initglobals {
   # defines $DIRECTORY  $DRSERVICESPATH  $SUPPORTIMAGE
   . "${DR_CFG_FILE}"
   
   # Check basic directories are okay
   checkdir "${DIRECTORY}" "DIRECTORY"
   checkdir "${DRSERVICESPATH}" "DRSERVICESPATH"
}

#------------------------------------------------------------------------------------

# serviceline SERVICE SHORTHELP
function serviceline {
   printf "   %-15s - %-55s\n" "$1" "$2"
}

#------------------------------------------------------------------------------------

# showservices
function showservices {
   # list available services. 
   echo "AVAILABLE SERVICES"
   NONEMPTYLIST=0
   find "$DRSERVICESPATH" -maxdepth 1 -mindepth 1 -type d | while read SPATH; do 
      NONEMPTYLIST=1
      if [ -e "${SPATH}/${SERVICECFGFILE}" ]; then
         . "${SPATH}/${SERVICECFGFILE}"
         serviceline "${SPATH##*/}" "$SERVICEIMAGENAME"
      else
         serviceline "${SPATH##*/}" "Broken service"
      fi
   done
   if [ "$NONEMPTYLIST" -eq 0 ]; then echo "   No services are installed." ; fi
}

#------------------------------------------------------------------------------------

# showusage
function showusage {
cat <<'EOF' >&2

NAME
   dr - docker runner
   
SYNOPSIS
   dr clean
   dr list
   
   [PASS=?] dr SERVICENAME backup BACKUPFILE
   [PASS=?] dr SERVICENAME restore BACKUPFILE
   dr SERVICENAME install IMAGENAME
   dr SERVICENAME update
   dr SERVICENAME destroy
   
   dr SERVICENAME
   dr SERVICENAME enter
   dr SERVICENAME COMMAND ARGS
   
   Once SERVICENAME is installed you can call it directly, e.g.
   SERVICENAME update
   This convenience just calls through to dr SERVICENAME update.

DESCRIPTION
   Provides a standard way to manage and run containers supporting dr.
   Intended to be used both manually and via Ansible.
   See https://github.com/j842/dr
   
EXIT CODE
   0   - success
   1   - error
   3   - no changes made
   
EOF
}

#------------------------------------------------------------------------------------

# command_exists
function command_exists { command -v "$1" >/dev/null 2>&1 ; }

#------------------------------------------------------------------------------------

# configure
function configure {
   if [ -z $DIRECTORY ]; then echo "dr configure requires directory argument.">&2 ; exit 1 ; fi
   mkdir -p "$DRETCPATH"   # ensure directrory exists.   
   echo "$DIRECTORY" > "${CFG_DIRECTORY}"
   
   # set up standard docker user and group for containers.
   groupadd -g 22022 "$DRGROUP"
   adduser --disabled-password --gecos '' -u 22022 --gid 22022 "$DRUSER"

   mkdir -p "$DIRECTORY"   # ensure directrory exists.
   
   echo "Configuration complete: created druser and set up $DIRECTORY." >&2
}

#------------------------------------------------------------------------------------

# checkimage 
function checkimage {
   # Check mandatory files in image (global var IMAGENAME) before touching host. Is it a valid dr container?
   for CFILE in "${REQDFILES[@]}"; do
      docker run --rm -it ${IMAGENAME} /bin/bash -c "command -v /dr/$CFILE >/dev/null 2>&1"
      if [ "$?" -ne 0 ]; then echo "${IMAGENAME} is not Docker Runner compatible. The script /dr/${CFILE} is missing.">&2 ; exit 1 ; fi
   done
   
   # Check running as druser.
   USERID=$(docker run --rm -it ${IMAGENAME} /bin/bash -c "id -u | tr -d '\r\n'")
   if [ "$USERID" != "22022" ]; then echo "${IMAGENAME} is not Docker Runner compatible. Not running as druser (uid 22022). It's >>$USERID<<">&2 ; exit 1 ; fi   
   
   echo "${IMAGENAME} is dr compatible.">&2
}

#------------------------------------------------------------------------------------

# createlaunchscript
function createlaunchscript {
   local SCRIPTPATH="/usr/local/bin/${SERVICENAME}"
   cat <<EOF >"$SCRIPTPATH"
#!/bin/bash
dr ${SERVICENAME} "\$@"
EOF
   chmod a+x "$SCRIPTPATH"
}

#------------------------------------------------------------------------------------

# copydrfiles
function copydrfiles {
   # the directory that the container will update.
   local DRBINPATH="${DIRSERVICE}/${DRBINDIR}"
   if [ -d "${DRBINPATH}" ]; then
      rm -r "${DRBINPATH}"
   fi
   mkdir -p "${DRBINPATH}"
   chown "${DRUSER}:${DRGROUP}" "${DRBINPATH}"
   
   # assumes docker image does not use entrypoint. Could instead override entrypoint maybe.
   docker run --rm -it -v "${DRBINPATH}:/tempcopy" "${IMAGENAME}" /bin/bash -c "cp -a /dr/* /tempcopy/"                             
   if [ $? -ne 0 ]; then 
      echo "Failed to copy files.">&2 
      echo "You will need to reinstall the service.">&2
      rm -r "${DIRSERVICE}"
      exit 1
   fi  
   chown -R root:root "${DRBINPATH}"
   chmod -R a-w "${DRBINPATH}"
}

#------------------------------------------------------------------------------------

# initdrservice
function initdirservice {
   # can only call when service directory not present (for safety)
   if [ -d ${DIRSERVICE} ]; then
      echo "A service is already installed at ${DIRSERVICE}. Initialisation cancelled.">&2
      echo "You might want   dr update ${SERVICENAME}  instead.">&2
      exit 1
   fi

   copydrfiles

   # add standard dr config stuff.
   mkdir -p "${DIRSERVICE}/${DRCFGDIR}"
   echo "${IMAGENAME}" > "${DIRSERVICE}/${CFG_IMAGENAME}"
   echo "${SERVICENAME}" > "${DIRSERVICE}/${CFG_SERVICENAME}" 

   # Check mandatory files made it over to host okay from the container.
   for HFILE in "${REQDFILES[@]}"; do
      if [ ! -e "${DIRSERVICE}/${DRBINDIR}/${HFILE}" ]; then 
         echo "Install failed - ${HFILE} is required" 
         rm -r "${DIRSERVICE}"
         exit 1
      fi
   done
}

#------------------------------------------------------------------------------------

# install
function install {   
   if [ -z $IMAGENAME ]; then echo "dr install requires IMAGENAME.">&2 ; exit 1 ; fi
   if [ -z $SERVICENAME ]; then echo "dr install requires SERVICENAME.">&2 ; exit 1 ; fi

   checkimage
   
   local DNAME="dr-install"

   # --- all four globals have been set.
   initdirservice
   
   # create the standard config volume container.
   docker volume create --name="dr-${SERVICENAME}-config" >/dev/null
   # set permissions on config volume
   docker run --name="$DNAME" -v "dr-${SERVICENAME}-config:/config" "${COPYIMAGE}" /bin/bash -c "chown druser:drgroup /config && date >> /config/install_date"
   docker rm "$DNAME" >/dev/null 
    
   # Run the install script, e.g. to create volume containers.
   # todo: tidy up return/exit codes!         
   bash "${DIRSERVICE}/${DRBINDIR}/install" "${SERVICENAME}" "${IMAGENAME}"
   
   # allow direct execution of SERVICENAME without typing dr
   createlaunchscript
    
   # TODO: If we had errors then destroy everything!
   echo "Installation of service ${SERVICENAME} successful."
}

#------------------------------------------------------------------------------------

# destroy
function destroy {
   if [ -z $SERVICENAME ]; then die "dr destroy requires SERVICENAME to be set." ; fi
   if [ ! -d "$DIRSERVICE" ]; then echo "The service ${SERVICENAME} does not exist.">&2 ; showservices ; exit 1 ; fi
   
   local RVALD=0

   # if the install process created a destroy script then run it, e.g. to destroy volume containers.
   # todo: tidy up return/exit codes!         
   if [ -e "${DIRSERVICE}/${DRBINDIR}/destroy" ]; then
      bash "${DIRSERVICE}/${DRBINDIR}/destroy" "${SERVICENAME}" "${IMAGENAME}"
   else 
      RVALD=1
   fi      
   
   # remove volume container.
   docker volume rm "dr-${SERVICENAME}-config" >/dev/null
   
   # remove launch script
   if [ -e "/usr/local/bin/${SERVICENAME}" ]; then rm "/usr/local/bin/${SERVICENAME}" ; fi
   
   # clean up service directory.
   rm -r "${DIRSERVICE}"
   
   exit $RVALD
}

#------------------------------------------------------------------------------------
# compress SOURCEFOLDER ARCHIVEFOLDER ARCHIVENAME [PASS]
function compress {
   local SOURCEFOLDER=$(realpath "$1" | tr -d '\r\n')
   if [ $? -ne 0 ]; then die "dr function compress: Couldn't find source path ${1}." ; fi
   local ARCHIVEFOLDER=$(realpath "$2" | tr -d '\r\n')
   if [ $? -ne 0 ]; then die "dr function compress: Couldn't find destination path ${2}." ; fi
   local ARCHIVEPATH="$ARCHIVEFOLDER/$3"
   local PASSCMD=""
   if [ -n "$4" ]; then PASSCMD="-p${4}"; fi
   
   tar cf - -C "$SOURCEFOLDER" . | 7za a -si "${PASSCMD}" "$ARCHIVEPATH" > /dev/null
   if [ $? -ne 0 ]; then die "Failed to create archive of $SOURCEFOLDER" ; fi
}

# decompress DESTFOLDER ARCHIVEFOLDER ARCHIVENAME [PASS]
function decompress {
   local DESTFOLDER=$(realpath "$1" | tr -d '\r\n')
   local ARCHIVEFOLDER=$(realpath "$2" | tr -d '\r\n')
   local ARCHIVEPATH="$ARCHIVEFOLDER/$3"

   if [ ! -e "$ARCHIVEPATH" ]; then die "dr function decompress: No such archive: $ARCHIVEPATH"; fi
   if [ ! -d "$DESTFOLDER" ]; then die "dr function decompress: Destination folder does not exist: $DESTFOLDER"; fi
   local PASSCMD=""
   if [ -n "$4" ]; then PASSCMD="-p${4}"; fi
   
   7za x -so "${PASSCMD}" "${ARCHIVEPATH}" | tar xf - -C "${DESTFOLDER}"
   if [ $? -ne 0 ]; then die "Failed to decompress archive $ARCHIVEPATH . The password may be incorrect!"; fi
}

# compressvolume VOLUMENAME ARCHIVEFOLDER ARCHIVENAME
function compressvolume {
   local VOLUMENAME="$1"
   local ARCHIVEFOLDER=$(realpath "$2" | tr -d '\r\n')
   if [ $? -ne 0 ]; then die "dr function compressvolume: Couldn't find destination path $2." ; fi
   local ARCHIVENAME="$3"
   local DCNAME="dr-compressvolume"

   docker run --name="${DCNAME}" \
      -v "${VOLUMENAME}:/vol" -v "${ARCHIVEFOLDER}:/archive" "${COPYIMAGE}" \
      /bin/bash -c "tar zcf /archive/${ARCHIVENAME} -C /vol ."
   docker rm "${DCNAME}" >/dev/null 
}

# decompressvolume VOLUMENAME ARCHIVEFOLDER ARCHIVENAME
function decompressvolume {
   local VOLUMENAME="$1"
   local ARCHIVEFOLDER=$(realpath "$2" | tr -d '\r\n')
   local ARCHIVENAME="$3"
   if [ ! -e "$ARCHIVEFOLDER/$ARCHIVENAME" ]; then die "dr function decompressvolume: Couldn't find archive $ARCHIVENAME" ; fi
   local DCNAME="dr-decompressvolume"

   # destroy any pre-existing data!
   docker volume rm "${VOLUMENAME}" >/dev/null
   docker volume create --name="${VOLUMENAME}" >/dev/null
   docker run --name="${DCNAME}" \
      -v "${VOLUMENAME}:/vol" -v "${ARCHIVEFOLDER}:/archive" "${COPYIMAGE}" \
      /bin/bash -c "tar zxf /archive/${ARCHIVENAME} -C /vol"
   docker rm "${DCNAME}" >/dev/null 
}

#------------------------------------------------------------------------------------

# backup BACKUPFILE
function backup {
   if [ -z "$1" ]; then die "No BACKUPFILE was specified." ; fi
   local BACKUPFILE=$(realpath "$1" | tr -d '\r\n')
   if [ -e "$BACKUPFILE" ]; then die "$BACKUPFILE already exists. Aborting." ; fi
   
   local TEMPROOT="$(mktemp -d)"
   local TEMPPARENT="${TEMPROOT}/backup"
   local TEMPF="${TEMPPARENT}/drbackup"
   mkdir -p "$TEMPF"
   local TEMPC="${TEMPPARENT}/containerbackup"
   mkdir -p "$TEMPC"
   
   # for convenience, stick teh imagename in the tempparent folder
   echo "${IMAGENAME}" > "$TEMPPARENT/imagename.txt"
   
   # back up our configuration directory.
   compress "$DIRSERVICE/${DRCFGDIR}" "${TEMPF}" "${BACKUP_HOSTZIP}"
   
   # back up our volume container (dr-${SERVICENAME}-config).
   compressvolume "dr-${SERVICENAME}-config" "${TEMPF}" "${BACKUP_VOLZIP}"
   
   # call through to container to backup anything there in a subfolder.
   SCRIPTTORUN="${DIRSERVICE}/${DRBINDIR}/backup"
   bash "$SCRIPTTORUN" "$SERVICENAME" "$IMAGENAME" "$TEMPC"
      
   # Compress everything with password
   compress "$TEMPPARENT" "$TEMPROOT" "${BACKUP_MAIN}" "$PASS"
   mv "${TEMPROOT}/${BACKUP_MAIN}" "$BACKUPFILE"

   rm -r "${TEMPROOT}"
   echo " ">&2
   if [ -z "$PASS" ]; then "WARNING: No password supplied. Backup is not encrypted!">&2 ; fi
   echo "Backed up to $BACKUPFILE succesfully.">&2
}

#------------------------------------------------------------------------------------

# restore BACKUPFILE
function restore {
   if [ -z "$1" ]; then die "No BACKUPFILE was specified." ; fi
   local BACKUPFILE=$(realpath "$1" | tr -d '\r\n')
   if [ ! -e "$BACKUPFILE" ]; then die "$BACKUPFILE doesn't exist. Aborting." ; fi
   if [ -e "$DIRSERVICE" ]; then die "$SERVICENAME exists - destroy it before restoring from backup." ; fi
   
   local TEMPROOT="$(mktemp -d)"
   local TEMPPARENT="${TEMPROOT}/backup"
   local TEMPF="${TEMPPARENT}/drbackup"
   mkdir -p "$TEMPF"
   local TEMPC="${TEMPPARENT}/containerbackup"
   mkdir -p "$TEMPC"
   
   # decompress the main backup
   cp "$BACKUPFILE" "${TEMPROOT}/${BACKUP_MAIN}"
   decompress "$TEMPPARENT" "$TEMPROOT" "$BACKUP_MAIN" "$PASS"
      
   # check backup has key files.
   local KEYFILES=("${TEMPF}/${BACKUP_HOSTZIP}" "${TEMPF}/${BACKUP_VOLZIP}" "${TEMPPARENT}/imagename.txt")
   for NEEDEDFILE in "${KEYFILES[@]}"; do
      if [ ! -e "$NEEDEDFILE" ]; then die "Backup corrupt. Missing ${NEEDEDFILE}."; fi
   done
   
   # set IMAGENAME - the only missing global var.
   IMAGENAME=$(<"$TEMPPARENT/imagename.txt")

   # now can install base service
   install
        
   # restore our volume container (dr-${SERVICENAME}-config), first destroying the one install just created.
   decompressvolume "dr-${SERVICENAME}-config" "${TEMPF}" "${BACKUP_VOLZIP}"

   # restore our configuration, first removing the one install just created.
   rm -r "${DIRSERVICE}/${DRCFGDIR}"
   mkdir "${DIRSERVICE}/${DRCFGDIR}"
   decompress "${DIRSERVICE}/${DRCFGDIR}" "${TEMPF}" "${BACKUP_HOSTZIP}"
   
   # call through to container to restore anything there.
   SCRIPTTORUN="${DIRSERVICE}/${DRBINDIR}/restore"
   bash "$SCRIPTTORUN" "$SERVICENAME" "$IMAGENAME" "$TEMPC"
   
   echo "Service ${SERVICENAME} has been restored successfully."
}

#------------------------------------------------------------------------------------


# retriveDIRECTORY
function retrieveDIRECTORY {
   DIRERR="Run   dr configure DIRECTORY   before any other commands."
   if [ ! -d "$DRETCDIR" ]; then die "$DIRERR"; fi
   DIRECTORY=$(<"${CFG_DIRECTORY}")
   if [ -z "$DIRECTORY" ]; then die "$DIRERR"; fi
   if [ ! -d "$DIRECTORY" ]; then die "$DIRERR"; fi
}

#------------------------------------------------------------------------------------

# setglobals
function setglobals {
   # expects SERVICENAME to be set.
   if [ -z "${SERVICENAME}" ]; then 
      die "SERVICENAME has not been set." 
   fi
   retrieveDIRECTORY

   DIRSERVICE="${DIRECTORY}/${SERVICENAME}"
   if [ ! -d "$DIRSERVICE" ]; then echo "The service ${SERVICENAME} does not exist.">&2 ; showservices ; exit 1 ; fi

   if [ ! -e "${DIRSERVICE}/${CFG_IMAGENAME}" ]; then die "Error - ${CFG_IMAGENAME} doesn't exist."; fi
   IMAGENAME=$(<"${DIRSERVICE}/${CFG_IMAGENAME}")
   if [ -z "$IMAGENAME" ]; then die "Error - ${CFG_IMAGENAME} is empty." ; fi
}

#------------------------------------------------------------------------------------

# ███╗   ███╗ █████╗ ██╗███╗   ██╗
# ████╗ ████║██╔══██╗██║████╗  ██║
# ██╔████╔██║███████║██║██╔██╗ ██║
# ██║╚██╔╝██║██╔══██║██║██║╚██╗██║
# ██║ ╚═╝ ██║██║  ██║██║██║ ╚████║
# ╚═╝     ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝
                                

if [ "$EUID" -ne 0 ]; then echo "Please run as root" ; exit 1 ; fi
if ! command_exists docker ; then die "Requires docker to be installed." ; fi
if [ "$(uname -rv | grep -c Debian)" -eq 0 ]; then die "Built for Debian only." ; fi

# Check basic commands are available
COMMANDS=(gpg wget md5sum 7z 7za)
for NEEDEDCMD in "${COMMANDS[@]}"; do
  if ! command_exists "${NEEDEDCMD}" ; then die "${NEEDEDCMD} is not installed." ; fi
done

# defines $DIRECTORY  $DRSERVICESPATH  $SUPPORTIMAGE
initglobals

# check special commands with no SERVICENAME needed
if [ "$#" -eq 0 ]; then 
   showusage
   showservices
   exit 0
elif [ "$1" -eq "clean" ]; then
   docker run --rm -v /var/run/docker.sock:/var/run/docker.sock spotify/docker-gc
   exit 0
elif [ "$1" -eq "list" ]; then
   showservices 
   exit 0
fi     

# all other commands have SERVICENAME as first argument.




CMD="$1" ; shift

case "$CMD" in
   configure)
      if [ "$1" ]; then
         DIRECTORY="$1"
         configure
      else
         dieusage "dr configure DIRECTORY"
      fi
      ;;

   install)
      if [ "$1" ] && [ "$2" ]; then
         IMAGENAME="$1"
         SERVICENAME="$2"
         retrieveDIRECTORY
         DIRSERVICE="${DIRECTORY}/${SERVICENAME}"
         install
      else
         dieusage "dr install IMAGENAME SERVICENAME"
      fi
      ;;
      
   update)
      if [ "$1" ]; then
         SERVICENAME="$1"
         setglobals
         copydrfiles
      else
         dieusage "dr update SERVICENAME"
      fi         
      ;;
      
   # dr backup SERVICENAME BACKUPFILE
   backup)
      if [ "$1" ] && [ "$2" ]; then
         SERVICENAME="$1"
         setglobals
         backup "$2"
      else
         dieusage "[PASS=?] dr backup SERVICENAME BACKUPFILE"
      fi
      ;;
     
   # dr restore SERVICENAME BACKUPFILE
   restore)
      if [ "$1" ] && [ "$2" ]; then
         SERVICENAME="$1"
         retrieveDIRECTORY
         DIRSERVICE="${DIRECTORY}/${SERVICENAME}"
         restore "$2"
      else
         dieusage "[PASS=?] dr restore SERVICENAME BACKUPFILE"
      fi
      ;;
     
   #--------------------------         
      
   destroy)
      if [ "$1" ]; then
         SERVICENAME="$1" ; shift
         setglobals
         destroy 
      else
         dieusage "dr destroy SERVICENAME"
      fi
      ;;
      
   
   *)
      # check if CMD matches a service. If so run the appropriate script.
      # format:   dr SERVICENAME COMMAND ARGS
      SERVICENAME="$CMD"
      setglobals
      
      SUBCOMMAND="$1" ; shift
      SCRIPTTORUN="${DIRSERVICE}/${DRBINDIR}/${SUBCOMMAND}"
      if [ -n "$SUBCOMMAND" ] && [ -e "${SCRIPTTORUN}" ]; then
         bash "${SCRIPTTORUN}" "${SERVICENAME}" "${IMAGENAME}" "$@"
      else
         bash "${DIRSERVICE}/${DRBINDIR}/help" "${SERVICENAME}" "${IMAGENAME}"
      fi
      ;;
esac


