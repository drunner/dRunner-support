#!/bin/bash

#-----------------------------------------------------------------------------------------------------------------------------

# die MESSAGE 
# colourful way to die.
function die {
   if [ -n "$1" ]; then
      echo " ">&2 ; echo -e "\e[31m\e[1m${1}\e[0m">&2  ; echo " ">&2
   else
      echo " ">&2 ; echo -e "\e[31m\e[1mUnexpected error. Exiting.\e[0m">&2  ; echo " ">&2
      fi
   exit 1
}

#-----------------------------------------------------------------------------------------------------------------------------

# Global constants for pretty code.
# require  echo -e 
readonly CODE_S="\e[32m"
readonly CODE_E="\e[0m"

#-----------------------------------------------------------------------------------------------------------------------------

# dieusage USAGEMESSAGE
# die, showing how we should be used.
function dieusage {
   echo "Usage:">&2
   echo -e "   ${CODE_S}$1${CODE_E}" >&2
   exit 1
}

#-----------------------------------------------------------------------------------------------------------------------------

# check whether a docker volume exists on the host.
function volexists {
  docker volume ls | grep "$1" > /dev/null
}

#------------------------------------------------------------------------------------

# getUSERID IMAGENAME
# get the ID of the user running in a docker container.
function getUSERID {
   if [ -z "$1" ]; then die "getUSERID: requires IMAGENAME passed as first argument."; fi
   USERID=$(docker run --rm -it "${1}" /bin/bash -c "id -u | tr -d '\r\n'")
   if [ $? -ne 0 ]; then die "getUSERID: Docker image ${1} does not exist." ; fi
}

#------------------------------------------------------------------------------------

# command_exists
# see if the given command exists in the current users path
# if comannd_exists docker ; then ...
function command_exists { command -v "$1" >/dev/null 2>&1 ; }

#------------------------------------------------------------------------------------

# elementIn element array
# if elementIn "a string" "${array[@]}" ; then ...
function elementIn {
  local e
  for e in "${@:2}"; do [[ "$e" == "$1" ]] && return 0; done
  return 1
}


#------------------------------------------------------------------------------------

# validate-image
function validate-image  {
   if [ ! -v ROOTPATH ] || [ -z "$ROOTPATH" ]; then die "validate-image: ROOTPATH is not set." ; fi
   if [ ! -v IMAGENAME ] || [ -z "$IMAGENAME" ]; then die "validate-image: IMAGENAME is not set." ; fi
   if [ ! -e "${ROOTPATH}/support/validator-image" ]; then
      die "Missing dr file: ${ROOTPATH}/support/validator-image"
   fi
   docker run --rm -v "${ROOTPATH}/support:/support" "${IMAGENAME}" /bin/bash -c "/support/validator-image"
   if [ "$?" -ne 0 ]; then 
      die "Unable to continue because ${IMAGENAME} is not Docker Runner compatible."
   fi
   
   echo "${IMAGENAME} is dr compatible.">&2
}

#------------------------------------------------------------------------------------

# destroy
# destroys everything we can about a service!
function destroy {   
   # call destroy in service.
   if [ ! -v SERVICENAME ]; then 
      die "Can't destroy because SERVICENAME is not set."
   fi

   if [ -v SERVICERUNNERPATH ] && [ -e "${SERVICERUNNERPATH}" ]; then 
      bash "${SERVICERUNNERPATH}" destroy
   fi
   
   # remove volume containers.
   if [ -v DOCKERVOLS ]; then
      for VOLNAME in "${DOCKERVOLS[@]}"; do      
         docker volume rm "$VOLNAME" >/dev/null
      done
   fi
   
   # remove launch script
   if [ -e "/usr/local/bin/${SERVICENAME}" ]; then 
      rm "/usr/local/bin/${SERVICENAME}"
   fi
   
   # delete service directoy.
   if [ -d "${ROOTPATH}/services/${SERVICENAME}" ]; then
      rm -r "${ROOTPATH}/services/${SERVICENAME}"
   fi
   
   echo "Service $SERVICENAME has been destroyed."
}


#------------------------------------------------------------------------------------
